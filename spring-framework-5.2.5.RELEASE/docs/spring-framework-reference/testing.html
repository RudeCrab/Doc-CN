<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>Testing</title>
<style>
@import 'css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	$('.switch--item').each(function() {
		blockId = blockIdForSwitchItem($(this));
		$(this).off('click');
		$(this).on('click', function() {
			selectedText = $(this).text()
			window.localStorage.setItem(blockId, selectedText);
			$(".switch--item").filter(function() {
				return blockIdForSwitchItem($(this)) === blockId;
			}).filter(function() {
				return $(this).text() === selectedText;
			}).each(function() {
				select($(this))
			});
		});
		if ($(this).text() === window.localStorage.getItem(blockId)) {
			select($(this))
		}
	});
}

function blockIdForSwitchItem(item) {
	idComponents = []
	idComponents.push(item.text().toLowerCase());
	item.siblings(".switch--item").each(function(index, sibling) {
		idComponents.push($(sibling).text().toLowerCase());
	});
	return idComponents.sort().join("-")
}

function select(selected) {
	selected.addClass('selected');
	selected.siblings().removeClass('selected');
	selectedContent = selected.parent().siblings(".content").eq(selected.index())
	selectedContent.removeClass('hidden');
	selectedContent.siblings().addClass('hidden');
}

$(addBlockSwitches);
$(globalSwitch);

</script>

</head>
<body id="testing" class="book toc2 toc-left">
<div id="header">
<h1>Testing</h1>
<div class="details">
<span id="revnumber">version 5.2.5.RELEASE</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#testing-introduction">1. Introduction to Spring Testing</a></li>
<li><a href="#unit-testing">2. Unit Testing</a>
<ul class="sectlevel2">
<li><a href="#mock-objects">2.1. Mock Objects</a>
<ul class="sectlevel3">
<li><a href="#mock-objects-env">2.1.1. Environment</a></li>
<li><a href="#mock-objects-jndi">2.1.2. JNDI</a></li>
<li><a href="#mock-objects-servlet">2.1.3. Servlet API</a></li>
<li><a href="#mock-objects-web-reactive">2.1.4. Spring Web Reactive</a></li>
</ul>
</li>
<li><a href="#unit-testing-support-classes">2.2. Unit Testing Support Classes</a>
<ul class="sectlevel3">
<li><a href="#unit-testing-utilities">2.2.1. General Testing Utilities</a></li>
<li><a href="#unit-testing-spring-mvc">2.2.2. Spring MVC Testing Utilities</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#integration-testing">3. Integration Testing</a>
<ul class="sectlevel2">
<li><a href="#integration-testing-overview">3.1. Overview</a></li>
<li><a href="#integration-testing-goals">3.2. Goals of Integration Testing</a>
<ul class="sectlevel3">
<li><a href="#testing-ctx-management">3.2.1. Context Management and Caching</a></li>
<li><a href="#testing-fixture-di">3.2.2. Dependency Injection of Test Fixtures</a></li>
<li><a href="#testing-tx">3.2.3. Transaction Management</a></li>
<li><a href="#testing-support-classes">3.2.4. Support Classes for Integration Testing</a></li>
</ul>
</li>
<li><a href="#integration-testing-support-jdbc">3.3. JDBC Testing Support</a></li>
<li><a href="#integration-testing-annotations">3.4. Annotations</a>
<ul class="sectlevel3">
<li><a href="#integration-testing-annotations-spring">3.4.1. Spring Testing Annotations</a>
<ul class="sectlevel4">
<li><a href="#spring-testing-annotation-bootstrapwith"><code>@BootstrapWith</code></a></li>
<li><a href="#spring-testing-annotation-contextconfiguration"><code>@ContextConfiguration</code></a></li>
<li><a href="#spring-testing-annotation-webappconfiguration"><code>@WebAppConfiguration</code></a></li>
<li><a href="#spring-testing-annotation-contexthierarchy"><code>@ContextHierarchy</code></a></li>
<li><a href="#spring-testing-annotation-activeprofiles"><code>@ActiveProfiles</code></a></li>
<li><a href="#spring-testing-annotation-testpropertysource"><code>@TestPropertySource</code></a></li>
<li><a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a></li>
<li><a href="#spring-testing-annotation-testexecutionlisteners"><code>@TestExecutionListeners</code></a></li>
<li><a href="#spring-testing-annotation-commit"><code>@Commit</code></a></li>
<li><a href="#spring-testing-annotation-rollback"><code>@Rollback</code></a></li>
<li><a href="#spring-testing-annotation-beforetransaction"><code>@BeforeTransaction</code></a></li>
<li><a href="#spring-testing-annotation-aftertransaction"><code>@AfterTransaction</code></a></li>
<li><a href="#spring-testing-annotation-sql"><code>@Sql</code></a></li>
<li><a href="#spring-testing-annotation-sqlconfig"><code>@SqlConfig</code></a></li>
<li><a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code></a></li>
<li><a href="#spring-testing-annotation-sqlgroup"><code>@SqlGroup</code></a></li>
</ul>
</li>
<li><a href="#integration-testing-annotations-standard">3.4.2. Standard Annotation Support</a></li>
<li><a href="#integration-testing-annotations-junit4">3.4.3. Spring JUnit 4 Testing Annotations</a>
<ul class="sectlevel4">
<li><a href="#integration-testing-annotations-junit4-ifprofilevalue"><code>@IfProfileValue</code></a></li>
<li><a href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"><code>@ProfileValueSourceConfiguration</code></a></li>
<li><a href="#integration-testing-annotations-junit4-timed"><code>@Timed</code></a></li>
<li><a href="#integration-testing-annotations-junit4-repeat"><code>@Repeat</code></a></li>
</ul>
</li>
<li><a href="#integration-testing-annotations-junit-jupiter">3.4.4. Spring JUnit Jupiter Testing Annotations</a>
<ul class="sectlevel4">
<li><a href="#integration-testing-annotations-junit-jupiter-springjunitconfig"><code>@SpringJUnitConfig</code></a></li>
<li><a href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"><code>@SpringJUnitWebConfig</code></a></li>
<li><a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a></li>
<li><a href="#integration-testing-annotations-junit-jupiter-enabledif"><code>@EnabledIf</code></a></li>
<li><a href="#integration-testing-annotations-junit-jupiter-disabledif"><code>@DisabledIf</code></a></li>
</ul>
</li>
<li><a href="#integration-testing-annotations-meta">3.4.5. Meta-Annotation Support for Testing</a></li>
</ul>
</li>
<li><a href="#testcontext-framework">3.5. Spring TestContext Framework</a>
<ul class="sectlevel3">
<li><a href="#testcontext-key-abstractions">3.5.1. Key Abstractions</a>
<ul class="sectlevel4">
<li><a href="#testcontext"><code>TestContext</code></a></li>
<li><a href="#testcontextmanager"><code>TestContextManager</code></a></li>
<li><a href="#testexecutionlistener"><code>TestExecutionListener</code></a></li>
<li><a href="#context-loaders">Context Loaders</a></li>
</ul>
</li>
<li><a href="#testcontext-bootstrapping">3.5.2. Bootstrapping the TestContext Framework</a></li>
<li><a href="#testcontext-tel-config">3.5.3. <code>TestExecutionListener</code> Configuration</a>
<ul class="sectlevel4">
<li><a href="#testcontext-tel-config-registering-tels">Registering <code>TestExecutionListener</code> Implementations</a></li>
<li><a href="#testcontext-tel-config-automatic-discovery">Automatic Discovery of Default <code>TestExecutionListener</code> Implementations</a></li>
<li><a href="#testcontext-tel-config-ordering">Ordering <code>TestExecutionListener</code> Implementations</a></li>
<li><a href="#testcontext-tel-config-merging">Merging <code>TestExecutionListener</code> Implementations</a></li>
</ul>
</li>
<li><a href="#testcontext-test-execution-events">3.5.4. Test Execution Events</a>
<ul class="sectlevel4">
<li><a href="#testcontext-test-execution-events-exception-handling">Exception Handling</a></li>
<li><a href="#testcontext-test-execution-events-async">Asynchronous Listeners</a></li>
</ul>
</li>
<li><a href="#testcontext-ctx-management">3.5.5. Context Management</a>
<ul class="sectlevel4">
<li><a href="#testcontext-ctx-management-xml">Context Configuration with XML resources</a></li>
<li><a href="#testcontext-ctx-management-groovy">Context Configuration with Groovy Scripts</a></li>
<li><a href="#testcontext-ctx-management-javaconfig">Context Configuration with Component Classes</a></li>
<li><a href="#testcontext-ctx-management-mixed-config">Mixing XML, Groovy Scripts, and Component Classes</a></li>
<li><a href="#testcontext-ctx-management-initializers">Context Configuration with Context Initializers</a></li>
<li><a href="#testcontext-ctx-management-inheritance">Context Configuration Inheritance</a></li>
<li><a href="#testcontext-ctx-management-env-profiles">Context Configuration with Environment Profiles</a></li>
<li><a href="#testcontext-ctx-management-property-sources">Context Configuration with Test Property Sources</a></li>
<li><a href="#testcontext-ctx-management-dynamic-property-sources">Context Configuration with Dynamic Property Sources</a></li>
<li><a href="#testcontext-ctx-management-web">Loading a <code>WebApplicationContext</code></a></li>
<li><a href="#testcontext-ctx-management-caching">Context Caching</a></li>
<li><a href="#testcontext-ctx-management-ctx-hierarchies">Context Hierarchies</a></li>
</ul>
</li>
<li><a href="#testcontext-fixture-di">3.5.6. Dependency Injection of Test Fixtures</a></li>
<li><a href="#testcontext-web-scoped-beans">3.5.7. Testing Request- and Session-scoped Beans</a></li>
<li><a href="#testcontext-tx">3.5.8. Transaction Management</a>
<ul class="sectlevel4">
<li><a href="#testcontext-tx-test-managed-transactions">Test-managed Transactions</a></li>
<li><a href="#testcontext-tx-enabling-transactions">Enabling and Disabling Transactions</a></li>
<li><a href="#testcontext-tx-rollback-and-commit-behavior">Transaction Rollback and Commit Behavior</a></li>
<li><a href="#testcontext-tx-programmatic-tx-mgt">Programmatic Transaction Management</a></li>
<li><a href="#testcontext-tx-before-and-after-tx">Running Code Outside of a Transaction</a></li>
<li><a href="#testcontext-tx-mgr-config">Configuring a Transaction Manager</a></li>
<li><a href="#testcontext-tx-annotation-demo">Demonstration of All Transaction-related Annotations</a></li>
</ul>
</li>
<li><a href="#testcontext-executing-sql">3.5.9. Executing SQL Scripts</a>
<ul class="sectlevel4">
<li><a href="#testcontext-executing-sql-programmatically">Executing SQL scripts programmatically</a></li>
<li><a href="#testcontext-executing-sql-declaratively">Executing SQL scripts declaratively with @Sql</a></li>
</ul>
</li>
<li><a href="#testcontext-parallel-test-execution">3.5.10. Parallel Test Execution</a></li>
<li><a href="#testcontext-support-classes">3.5.11. TestContext Framework Support Classes</a>
<ul class="sectlevel4">
<li><a href="#testcontext-junit4-runner">Spring JUnit 4 Runner</a></li>
<li><a href="#testcontext-junit4-rules">Spring JUnit 4 Rules</a></li>
<li><a href="#testcontext-support-classes-junit4">JUnit 4 Support Classes</a></li>
<li><a href="#testcontext-junit-jupiter-extension">SpringExtension for JUnit Jupiter</a></li>
<li><a href="#testcontext-junit-jupiter-di">Dependency Injection with <code>SpringExtension</code></a></li>
<li><a href="#testcontext-support-classes-testng">TestNG Support Classes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-mvc-test-framework">3.6. Spring MVC Test Framework</a>
<ul class="sectlevel3">
<li><a href="#spring-mvc-test-server">3.6.1. Server-Side Tests</a>
<ul class="sectlevel4">
<li><a href="#spring-mvc-test-server-static-imports">Static Imports</a></li>
<li><a href="#spring-mvc-test-server-setup-options">Setup Choices</a></li>
<li><a href="#spring-mvc-test-server-setup-steps">Setup Features</a></li>
<li><a href="#spring-mvc-test-server-performing-requests">Performing Requests</a></li>
<li><a href="#spring-mvc-test-server-defining-expectations">Defining Expectations</a></li>
<li><a href="#spring-mvc-test-async-requests">Async Requests</a></li>
<li><a href="#spring-mvc-test-vs-streaming-response">Streaming Responses</a></li>
<li><a href="#spring-mvc-test-server-filters">Filter Registrations</a></li>
<li><a href="#spring-mvc-test-vs-end-to-end-integration-tests">Spring MVC Test vs End-to-End Tests</a></li>
<li><a href="#spring-mvc-test-server-resources">Further Examples</a></li>
</ul>
</li>
<li><a href="#spring-mvc-test-server-htmlunit">3.6.2. HtmlUnit Integration</a>
<ul class="sectlevel4">
<li><a href="#spring-mvc-test-server-htmlunit-why">Why HtmlUnit Integration?</a></li>
<li><a href="#spring-mvc-test-server-htmlunit-mah">MockMvc and HtmlUnit</a></li>
<li><a href="#spring-mvc-test-server-htmlunit-webdriver">MockMvc and WebDriver</a></li>
<li><a href="#spring-mvc-test-server-htmlunit-geb">MockMvc and Geb</a></li>
</ul>
</li>
<li><a href="#spring-mvc-test-client">3.6.3. Client-Side REST Tests</a>
<ul class="sectlevel4">
<li><a href="#spring-mvc-test-client-static-imports">Static Imports</a></li>
<li><a href="#spring-mvc-test-client-resources">Further Examples of Client-side REST Tests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webtestclient">3.7. WebTestClient</a>
<ul class="sectlevel3">
<li><a href="#webtestclient-setup">3.7.1. Setup</a>
<ul class="sectlevel4">
<li><a href="#webtestclient-controller-config">Bind to Controller</a></li>
<li><a href="#webtestclient-fn-config">Bind to Router Function</a></li>
<li><a href="#webtestclient-context-config">Bind to <code>ApplicationContext</code></a></li>
<li><a href="#webtestclient-server-config">Bind to Server</a></li>
<li><a href="#webtestclient-client-config">Client Builder</a></li>
</ul>
</li>
<li><a href="#webtestclient-tests">3.7.2. Writing Tests</a>
<ul class="sectlevel4">
<li><a href="#webtestclient-no-content">No Content</a></li>
<li><a href="#webtestclient-json">JSON Content</a></li>
<li><a href="#webtestclient-stream">Streaming Responses</a></li>
<li><a href="#webtestclient-request-body">Request Body</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#testing-resources">4. Further Resources</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This chapter covers Spring&#8217;s support for integration testing and best practices for unit
testing. The Spring team advocates test-driven development (TDD). The Spring team has
found that the correct use of inversion of control (IoC) certainly does make both unit
and integration testing easier (in that the presence of setter methods and appropriate
constructors on classes makes them easier to wire together in a test without having to
set up service locator registries and similar structures).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-introduction"><a class="anchor" href="#testing-introduction"></a>1. Introduction to Spring Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Testing is an integral part of enterprise software development. This chapter focuses on
the value added by the IoC principle to <a href="#unit-testing">unit testing</a> and on the benefits
of the Spring Framework&#8217;s support for <a href="#integration-testing">integration testing</a>. (A
thorough treatment of testing in the enterprise is beyond the scope of this reference
manual.)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unit-testing"><a class="anchor" href="#unit-testing"></a>2. Unit Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dependency injection should make your code less dependent on the container than it would
be with traditional Java EE development. The POJOs that make up your application should
be testable in JUnit or TestNG tests, with objects instantiated by using the <code>new</code>
operator, without Spring or any other container. You can use <a href="#mock-objects">mock objects</a>
(in conjunction with other valuable testing techniques) to test your code in isolation.
If you follow the architecture recommendations for Spring, the resulting clean layering
and componentization of your codebase facilitate easier unit testing. For example,
you can test service layer objects by stubbing or mocking DAO or repository interfaces,
without needing to access persistent data while running unit tests.</p>
</div>
<div class="paragraph">
<p>True unit tests typically run extremely quickly, as there is no runtime infrastructure to
set up. Emphasizing true unit tests as part of your development methodology can boost
your productivity. You may not need this section of the testing chapter to help you write
effective unit tests for your IoC-based applications. For certain unit testing scenarios,
however, the Spring Framework provides mock objects and testing support classes, which
are described in this chapter.</p>
</div>
<div class="sect2">
<h3 id="mock-objects"><a class="anchor" href="#mock-objects"></a>2.1. Mock Objects</h3>
<div class="paragraph">
<p>Spring includes a number of packages dedicated to mocking:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#mock-objects-env">Environment</a></p>
</li>
<li>
<p><a href="#mock-objects-jndi">JNDI</a></p>
</li>
<li>
<p><a href="#mock-objects-servlet">Servlet API</a></p>
</li>
<li>
<p><a href="#mock-objects-web-reactive">Spring Web Reactive</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="mock-objects-env"><a class="anchor" href="#mock-objects-env"></a>2.1.1. Environment</h4>
<div class="paragraph">
<p>The <code>org.springframework.mock.env</code> package contains mock implementations of the
<code>Environment</code> and <code>PropertySource</code> abstractions (see
<a href="core.html#beans-definition-profiles">Bean Definition Profiles</a>
and <a href="core.html#beans-property-source-abstraction"><code>PropertySource</code> Abstraction</a>).
<code>MockEnvironment</code> and <code>MockPropertySource</code> are useful for developing
out-of-container tests for code that depends on environment-specific properties.</p>
</div>
</div>
<div class="sect3">
<h4 id="mock-objects-jndi"><a class="anchor" href="#mock-objects-jndi"></a>2.1.2. JNDI</h4>
<div class="paragraph">
<p>The <code>org.springframework.mock.jndi</code> package contains a partial implementation of the JNDI
SPI, which you can use to set up a simple JNDI environment for test suites or stand-alone
applications. If, for example, JDBC <code>DataSource</code> instances get bound to the same JNDI
names in test code as they do in a Java EE container, you can reuse both application code
and configuration in testing scenarios without modification.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The mock JNDI support in the <code>org.springframework.mock.jndi</code> package is
officially deprecated as of Spring Framework 5.2 in favor of complete solutions from third
parties such as <a href="https://github.com/h-thurow/Simple-JNDI">Simple-JNDI</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mock-objects-servlet"><a class="anchor" href="#mock-objects-servlet"></a>2.1.3. Servlet API</h4>
<div class="paragraph">
<p>The <code>org.springframework.mock.web</code> package contains a comprehensive set of Servlet API
mock objects that are useful for testing web contexts, controllers, and filters. These
mock objects are targeted at usage with Spring&#8217;s Web MVC framework and are generally more
convenient to use than dynamic mock objects (such as <a href="http://easymock.org/">EasyMock</a>)
or alternative Servlet API mock objects (such as <a href="http://www.mockobjects.com">MockObjects</a>).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Since Spring Framework 5.0, the mock objects in <code>org.springframework.mock.web</code> are
based on the Servlet 4.0 API.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Spring MVC Test framework builds on the mock Servlet API objects to provide an
integration testing framework for Spring MVC. See <a href="#spring-mvc-test-framework">Spring MVC Test Framework</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="mock-objects-web-reactive"><a class="anchor" href="#mock-objects-web-reactive"></a>2.1.4. Spring Web Reactive</h4>
<div class="paragraph">
<p>The <code>org.springframework.mock.http.server.reactive</code> package contains mock implementations
of <code>ServerHttpRequest</code> and <code>ServerHttpResponse</code> for use in WebFlux applications. The
<code>org.springframework.mock.web.server</code> package contains a mock <code>ServerWebExchange</code> that
depends on those mock request and response objects.</p>
</div>
<div class="paragraph">
<p>Both <code>MockServerHttpRequest</code> and <code>MockServerHttpResponse</code> extend from the same abstract
base classes as server-specific implementations and share behavior with them. For
example, a mock request is immutable once created, but you can use the <code>mutate()</code> method
from <code>ServerHttpRequest</code> to create a modified instance.</p>
</div>
<div class="paragraph">
<p>In order for the mock response to properly implement the write contract and return a
write completion handle (that is, <code>Mono&lt;Void&gt;</code>), it by default uses a <code>Flux</code> with
<code>cache().then()</code>, which buffers the data and makes it available for assertions in tests.
Applications can set a custom write function (for example, to test an infinite stream).</p>
</div>
<div class="paragraph">
<p>The <a href="#webtestclient">WebTestClient</a> builds on the mock request and response to provide support for
testing WebFlux applications without an HTTP server. The client can also be used for
end-to-end tests with a running server.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unit-testing-support-classes"><a class="anchor" href="#unit-testing-support-classes"></a>2.2. Unit Testing Support Classes</h3>
<div class="paragraph">
<p>Spring includes a number of classes that can help with unit testing. They fall into two
categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#unit-testing-utilities">General Testing Utilities</a></p>
</li>
<li>
<p><a href="#unit-testing-spring-mvc">Spring MVC Testing Utilities</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="unit-testing-utilities"><a class="anchor" href="#unit-testing-utilities"></a>2.2.1. General Testing Utilities</h4>
<div class="paragraph">
<p>The <code>org.springframework.test.util</code> package contains several general purpose utilities
for use in unit and integration testing.</p>
</div>
<div class="paragraph">
<p><code>ReflectionTestUtils</code> is a collection of reflection-based utility methods. You can use
these methods in testing scenarios where you need to change the value of a constant, set
a non-<code>public</code> field, invoke a non-<code>public</code> setter method, or invoke a non-<code>public</code>
configuration or lifecycle callback method when testing application code for use cases
such as the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ORM frameworks (such as JPA and Hibernate) that condone <code>private</code> or <code>protected</code> field
access as opposed to <code>public</code> setter methods for properties in a domain entity.</p>
</li>
<li>
<p>Spring&#8217;s support for annotations (such as <code>@Autowired</code>, <code>@Inject</code>, and <code>@Resource</code>),
that provide dependency injection for <code>private</code> or <code>protected</code> fields, setter methods,
and configuration methods.</p>
</li>
<li>
<p>Use of annotations such as <code>@PostConstruct</code> and <code>@PreDestroy</code> for lifecycle callback
methods.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/util/AopTestUtils.html"><code>AopTestUtils</code></a> is a collection of
AOP-related utility methods. You can use these methods to obtain a reference to the
underlying target object hidden behind one or more Spring proxies. For example, if you
have configured a bean as a dynamic mock by using a library such as EasyMock or Mockito,
and the mock is wrapped in a Spring proxy, you may need direct access to the underlying
mock to configure expectations on it and perform verifications. For Spring&#8217;s core AOP
utilities, see <a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/aop/support/AopUtils.html"><code>AopUtils</code></a> and
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/aop/framework/AopProxyUtils.html"><code>AopProxyUtils</code></a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="unit-testing-spring-mvc"><a class="anchor" href="#unit-testing-spring-mvc"></a>2.2.2. Spring MVC Testing Utilities</h4>
<div class="paragraph">
<p>The <code>org.springframework.test.web</code> package contains
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/web/ModelAndViewAssert.html"><code>ModelAndViewAssert</code></a>, which you
can use in combination with JUnit, TestNG, or any other testing framework for unit tests
that deal with Spring MVC <code>ModelAndView</code> objects.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Unit testing Spring MVC Controllers</div>
To unit test your Spring MVC <code>Controller</code> classes as POJOs, use <code>ModelAndViewAssert</code>
combined with <code>MockHttpServletRequest</code>, <code>MockHttpSession</code>, and so on from Spring&#8217;s
<a href="#mock-objects-servlet">Servlet API mocks</a>. For thorough integration testing of your
Spring MVC and REST <code>Controller</code> classes in conjunction with your <code>WebApplicationContext</code>
configuration for Spring MVC, use the
<a href="#spring-mvc-test-framework">Spring MVC Test Framework</a> instead.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="integration-testing"><a class="anchor" href="#integration-testing"></a>3. Integration Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section (most of the rest of this chapter) covers integration testing for Spring
applications. It includes the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-overview">Overview</a></p>
</li>
<li>
<p><a href="#integration-testing-goals">Goals of Integration Testing</a></p>
</li>
<li>
<p><a href="#integration-testing-support-jdbc">JDBC Testing Support</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations">Annotations</a></p>
</li>
<li>
<p><a href="#testcontext-framework">Spring TestContext Framework</a></p>
</li>
<li>
<p><a href="#spring-mvc-test-framework">Spring MVC Test Framework</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="integration-testing-overview"><a class="anchor" href="#integration-testing-overview"></a>3.1. Overview</h3>
<div class="paragraph">
<p>It is important to be able to perform some integration testing without requiring
deployment to your application server or connecting to other enterprise infrastructure.
Doing so lets you test things such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The correct wiring of your Spring IoC container contexts.</p>
</li>
<li>
<p>Data access using JDBC or an ORM tool. This can include such things as the correctness
of SQL statements, Hibernate queries, JPA entity mappings, and so forth.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Spring Framework provides first-class support for integration testing in the
<code>spring-test</code> module. The name of the actual JAR file might include the release version
and might also be in the long <code>org.springframework.test</code> form, depending on where you get
it from (see the <a href="core.html#dependency-management">section on Dependency Management</a>
for an explanation). This library includes the <code>org.springframework.test</code> package, which
contains valuable classes for integration testing with a Spring container. This testing
does not rely on an application server or other deployment environment. Such tests are
slower to run than unit tests but much faster than the equivalent Selenium tests or
remote tests that rely on deployment to an application server.</p>
</div>
<div class="paragraph">
<p>Unit and integration testing support is provided in the form of the annotation-driven
<a href="#testcontext-framework">Spring TestContext Framework</a>. The TestContext framework is
agnostic of the actual testing framework in use, which allows instrumentation of tests
in various environments, including JUnit, TestNG, and others.</p>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-goals"><a class="anchor" href="#integration-testing-goals"></a>3.2. Goals of Integration Testing</h3>
<div class="paragraph">
<p>Spring&#8217;s integration testing support has the following primary goals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To manage <a href="#testing-ctx-management">Spring IoC container caching</a> between tests.</p>
</li>
<li>
<p>To provide <a href="#testing-fixture-di">Dependency Injection of test fixture instances</a>.</p>
</li>
<li>
<p>To provide <a href="#testing-tx">transaction management</a> appropriate to integration testing.</p>
</li>
<li>
<p>To supply <a href="#testing-support-classes">Spring-specific base classes</a> that assist
developers in writing integration tests.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The next few sections describe each goal and provide links to implementation and
configuration details.</p>
</div>
<div class="sect3">
<h4 id="testing-ctx-management"><a class="anchor" href="#testing-ctx-management"></a>3.2.1. Context Management and Caching</h4>
<div class="paragraph">
<p>The Spring TestContext Framework provides consistent loading of Spring
<code>ApplicationContext</code> instances and <code>WebApplicationContext</code> instances as well as caching
of those contexts. Support for the caching of loaded contexts is important, because
startup time can become an issue&#8201;&#8212;&#8201;not because of the overhead of Spring itself, but
because the objects instantiated by the Spring container take time to instantiate. For
example, a project with 50 to 100 Hibernate mapping files might take 10 to 20 seconds to
load the mapping files, and incurring that cost before running every test in every test
fixture leads to slower overall test runs that reduce developer productivity.</p>
</div>
<div class="paragraph">
<p>Test classes typically declare either an array of resource locations for XML or Groovy
configuration metadata&#8201;&#8212;&#8201;often in the classpath&#8201;&#8212;&#8201;or an array of component classes that
is used to configure the application. These locations or classes are the same as or
similar to those specified in <code>web.xml</code> or other configuration files for production
deployments.</p>
</div>
<div class="paragraph">
<p>By default, once loaded, the configured <code>ApplicationContext</code> is reused for each test.
Thus, the setup cost is incurred only once per test suite, and subsequent test execution
is much faster. In this context, the term &#8220;test suite&#8221; means all tests run in the same
JVM&#8201;&#8212;&#8201;for example, all tests run from an Ant, Maven, or Gradle build for a given project
or module. In the unlikely case that a test corrupts the application context and requires
reloading (for example, by modifying a bean definition or the state of an application
object) the TestContext framework can be configured to reload the configuration and
rebuild the application context before executing the next test.</p>
</div>
<div class="paragraph">
<p>See <a href="#testcontext-ctx-management">Context Management</a> and <a href="#testcontext-ctx-management-caching">Context Caching</a> with the
TestContext framework.</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-fixture-di"><a class="anchor" href="#testing-fixture-di"></a>3.2.2. Dependency Injection of Test Fixtures</h4>
<div class="paragraph">
<p>When the TestContext framework loads your application context, it can optionally
configure instances of your test classes by using Dependency Injection. This provides a
convenient mechanism for setting up test fixtures by using preconfigured beans from your
application context. A strong benefit here is that you can reuse application contexts
across various testing scenarios (for example, for configuring Spring-managed object
graphs, transactional proxies, <code>DataSource</code> instances, and others), thus avoiding the
need to duplicate complex test fixture setup for individual test cases.</p>
</div>
<div class="paragraph">
<p>As an example, consider a scenario where we have a class (<code>HibernateTitleRepository</code>)
that implements data access logic for a <code>Title</code> domain entity. We want to write
integration tests that test the following areas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The Spring configuration: Basically, is everything related to the configuration of the
<code>HibernateTitleRepository</code> bean correct and present?</p>
</li>
<li>
<p>The Hibernate mapping file configuration: Is everything mapped correctly and are the
correct lazy-loading settings in place?</p>
</li>
<li>
<p>The logic of the <code>HibernateTitleRepository</code>: Does the configured instance of this class
perform as anticipated?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See dependency injection of test fixtures with the
<a href="#testcontext-fixture-di">TestContext framework</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-tx"><a class="anchor" href="#testing-tx"></a>3.2.3. Transaction Management</h4>
<div class="paragraph">
<p>One common issue in tests that access a real database is their effect on the state of the
persistence store. Even when you use a development database, changes to the state may
affect future tests. Also, many operations&#8201;&#8212;&#8201;such as inserting or modifying persistent
data&#8201;&#8212;&#8201;cannot be performed (or verified) outside of a transaction.</p>
</div>
<div class="paragraph">
<p>The TestContext framework addresses this issue. By default, the framework creates and
rolls back a transaction for each test. You can write code that can assume the existence
of a transaction. If you call transactionally proxied objects in your tests, they behave
correctly, according to their configured transactional semantics. In addition, if a test
method deletes the contents of selected tables while running within the transaction
managed for the test, the transaction rolls back by default, and the database returns to
its state prior to execution of the test. Transactional support is provided to a test by
using a <code>PlatformTransactionManager</code> bean defined in the test&#8217;s application context.</p>
</div>
<div class="paragraph">
<p>If you want a transaction to commit (unusual, but occasionally useful when you want a
particular test to populate or modify the database), you can tell the TestContext
framework to cause the transaction to commit instead of roll back by using the
<a href="#integration-testing-annotations"><code>@Commit</code></a> annotation.</p>
</div>
<div class="paragraph">
<p>See transaction management with the <a href="#testcontext-tx">TestContext framework</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-support-classes"><a class="anchor" href="#testing-support-classes"></a>3.2.4. Support Classes for Integration Testing</h4>
<div class="paragraph">
<p>The Spring TestContext Framework provides several <code>abstract</code> support classes that
simplify the writing of integration tests. These base test classes provide well-defined
hooks into the testing framework as well as convenient instance variables and methods,
which let you access:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>ApplicationContext</code>, for performing explicit bean lookups or testing the state of
the context as a whole.</p>
</li>
<li>
<p>A <code>JdbcTemplate</code>, for executing SQL statements to query the database. You can use such
queries to confirm database state both before and after execution of database-related
application code, and Spring ensures that such queries run in the scope of the same
transaction as the application code. When used in conjunction with an ORM tool, be sure
to avoid <a href="#testcontext-tx-false-positives">false positives</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, you may want to create your own custom, application-wide superclass with
instance variables and methods specific to your project.</p>
</div>
<div class="paragraph">
<p>See support classes for the <a href="#testcontext-support-classes">TestContext framework</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-support-jdbc"><a class="anchor" href="#integration-testing-support-jdbc"></a>3.3. JDBC Testing Support</h3>
<div class="paragraph">
<p>The <code>org.springframework.test.jdbc</code> package contains <code>JdbcTestUtils</code>, which is a
collection of JDBC-related utility functions intended to simplify standard database
testing scenarios. Specifically, <code>JdbcTestUtils</code> provides the following static utility
methods.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>countRowsInTable(..)</code>: Counts the number of rows in the given table.</p>
</li>
<li>
<p><code>countRowsInTableWhere(..)</code>: Counts the number of rows in the given table by using the
provided <code>WHERE</code> clause.</p>
</li>
<li>
<p><code>deleteFromTables(..)</code>: Deletes all rows from the specified tables.</p>
</li>
<li>
<p><code>deleteFromTableWhere(..)</code>: Deletes rows from the given table by using the provided
<code>WHERE</code> clause.</p>
</li>
<li>
<p><code>dropTables(..)</code>: Drops the specified tables.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a>
and <a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>
provide convenience methods that delegate to the aforementioned methods in
<code>JdbcTestUtils</code>.</p>
</div>
<div class="paragraph">
<p>The <code>spring-jdbc</code> module provides support for configuring and launching an embedded
database, which you can use in integration tests that interact with a database.
For details, see <a href="data-access.html#jdbc-embedded-database-support">Embedded Database
Support</a> and <a href="data-access.html#jdbc-embedded-database-dao-testing">Testing Data Access
Logic with an Embedded Database</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-annotations"><a class="anchor" href="#integration-testing-annotations"></a>3.4. Annotations</h3>
<div class="paragraph">
<p>This section covers annotations that you can use when you test Spring applications.
It includes the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-annotations-spring">Spring Testing Annotations</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-standard">Standard Annotation Support</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4">Spring JUnit 4 Testing Annotations</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter Testing Annotations</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-meta">Meta-Annotation Support for Testing</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-spring"><a class="anchor" href="#integration-testing-annotations-spring"></a>3.4.1. Spring Testing Annotations</h4>
<div class="paragraph">
<p>The Spring Framework provides the following set of Spring-specific annotations that you
can use in your unit and integration tests in conjunction with the TestContext framework.
See the corresponding javadoc for further information, including default attribute
values, attribute aliases, and other details.</p>
</div>
<div class="paragraph">
<p>Spring&#8217;s testing annotations include the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-testing-annotation-bootstrapwith"><code>@BootstrapWith</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-contextconfiguration"><code>@ContextConfiguration</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-webappconfiguration"><code>@WebAppConfiguration</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-contexthierarchy"><code>@ContextHierarchy</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-activeprofiles"><code>@ActiveProfiles</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-testpropertysource"><code>@TestPropertySource</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-testexecutionlisteners"><code>@TestExecutionListeners</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-commit"><code>@Commit</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-rollback"><code>@Rollback</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-beforetransaction"><code>@BeforeTransaction</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-aftertransaction"><code>@AfterTransaction</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sql"><code>@Sql</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sqlconfig"><code>@SqlConfig</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sqlgroup"><code>@SqlGroup</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-bootstrapwith"><a class="anchor" href="#spring-testing-annotation-bootstrapwith"></a><code>@BootstrapWith</code></h5>
<div class="paragraph">
<p><code>@BootstrapWith</code> is a class-level annotation that you can use to configure how the Spring
TestContext Framework is bootstrapped. Specifically, you can use <code>@BootstrapWith</code> to
specify a custom <code>TestContextBootstrapper</code>. See the section on
<a href="#testcontext-bootstrapping">bootstrapping the TestContext framework</a> for further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-contextconfiguration"><a class="anchor" href="#spring-testing-annotation-contextconfiguration"></a><code>@ContextConfiguration</code></h5>
<div class="paragraph">
<p><code>@ContextConfiguration</code> defines class-level metadata that is used to determine how to
load and configure an <code>ApplicationContext</code> for integration tests. Specifically,
<code>@ContextConfiguration</code> declares the application context resource <code>locations</code> or the
component <code>classes</code> used to load the context.</p>
</div>
<div class="paragraph">
<p>Resource locations are typically XML configuration files or Groovy scripts located in the
classpath, while component classes are typically <code>@Configuration</code> classes. However,
resource locations can also refer to files and scripts in the file system, and component
classes can be <code>@Component</code> classes, <code>@Service</code> classes, and so on. See
<a href="#testcontext-ctx-management-javaconfig-component-classes">Component Classes</a> for further details.</p>
</div>
<div class="paragraph">
<p>The following example shows a <code>@ContextConfiguration</code> annotation that refers to an XML
file:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration("/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Referring to an XML file.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration("/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Referring to an XML file.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows a <code>@ContextConfiguration</code> annotation that refers to a class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration(classes = TestConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigClassApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Referring to a class.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration(classes = [TestConfig::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigClassApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Referring to a class.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As an alternative or in addition to declaring resource locations or component classes,
you can use <code>@ContextConfiguration</code> to declare <code>ApplicationContextInitializer</code> classes.
The following example shows such a case:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration(initializers = CustomContextIntializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextInitializerTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration(initializers = [CustomContextIntializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextInitializerTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declaring an initializer class.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can optionally use <code>@ContextConfiguration</code> to declare the <code>ContextLoader</code> strategy as
well. Note, however, that you typically do not need to explicitly configure the loader,
since the default loader supports <code>initializers</code> and either resource <code>locations</code> or
component <code>classes</code>.</p>
</div>
<div class="paragraph">
<p>The following example uses both a location and a loader:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration(locations = "/test-context.xml", loader = CustomContextLoader.class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomLoaderXmlApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configuring both a location and a custom loader.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration("/test-context.xml", loader = CustomContextLoader::class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomLoaderXmlApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configuring both a location and a custom loader.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@ContextConfiguration</code> provides support for inheriting resource locations or
configuration classes as well as context initializers that are declared by superclasses.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="#testcontext-ctx-management">Context Management</a> and the <code>@ContextConfiguration</code> javadocs for further
details.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-webappconfiguration"><a class="anchor" href="#spring-testing-annotation-webappconfiguration"></a><code>@WebAppConfiguration</code></h5>
<div class="paragraph">
<p><code>@WebAppConfiguration</code> is a class-level annotation that you can use to declare that the
<code>ApplicationContext</code> loaded for an integration test should be a <code>WebApplicationContext</code>.
The mere presence of <code>@WebAppConfiguration</code> on a test class ensures that a
<code>WebApplicationContext</code> is loaded for the test, using the default value of
<code>"file:src/main/webapp"</code> for the path to the root of the web application (that is, the
resource base path). The resource base path is used behind the scenes to create a
<code>MockServletContext</code>, which serves as the <code>ServletContext</code> for the test&#8217;s
<code>WebApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>@WebAppConfiguration</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration
@WebAppConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration
@WebAppConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@WebAppConfiguration</code> annotation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To override the default, you can specify a different base resource path by using the
implicit <code>value</code> attribute. Both <code>classpath:</code> and <code>file:</code> resource prefixes are
supported. If no resource prefix is supplied, the path is assumed to be a file system
resource. The following example shows how to specify a classpath resource:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration
@WebAppConfiguration("classpath:test-web-resources") <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying a classpath resource.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration
@WebAppConfiguration("classpath:test-web-resources") <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying a classpath resource.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that <code>@WebAppConfiguration</code> must be used in conjunction with
<code>@ContextConfiguration</code>, either within a single test class or within a test class
hierarchy. See the
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html"><code>@WebAppConfiguration</code></a>
javadoc for further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-contexthierarchy"><a class="anchor" href="#spring-testing-annotation-contexthierarchy"></a><code>@ContextHierarchy</code></h5>
<div class="paragraph">
<p><code>@ContextHierarchy</code> is a class-level annotation that is used to define a hierarchy of
<code>ApplicationContext</code> instances for integration tests. <code>@ContextHierarchy</code> should be
declared with a list of one or more <code>@ContextConfiguration</code> instances, each of which
defines a level in the context hierarchy. The following examples demonstrate the use of
<code>@ContextHierarchy</code> within a single test class (<code>@ContextHierarchy</code> can also be used
within a test class hierarchy):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
class ContextHierarchyTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextHierarchy(
    ContextConfiguration("/parent-config.xml"),
    ContextConfiguration("/child-config.xml"))
class ContextHierarchyTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = AppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class WebIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@WebAppConfiguration
@ContextHierarchy(
        ContextConfiguration(classes = [AppConfig::class]),
        ContextConfiguration(classes = [WebConfig::class]))
class WebIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to merge or override the configuration for a given level of the context
hierarchy within a test class hierarchy, you must explicitly name that level by supplying
the same value to the <code>name</code> attribute in <code>@ContextConfiguration</code> at each corresponding
level in the class hierarchy. See <a href="#testcontext-ctx-management-ctx-hierarchies">Context Hierarchies</a> and the
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/ContextHierarchy.html"><code>@ContextHierarchy</code></a> javadoc
for further examples.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-activeprofiles"><a class="anchor" href="#spring-testing-annotation-activeprofiles"></a><code>@ActiveProfiles</code></h5>
<div class="paragraph">
<p><code>@ActiveProfiles</code> is a class-level annotation that is used to declare which bean
definition profiles should be active when loading an <code>ApplicationContext</code> for an
integration test.</p>
</div>
<div class="paragraph">
<p>The following example indicates that the <code>dev</code> profile should be active:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration
@ActiveProfiles("dev") <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indicate that the <code>dev</code> profile should be active.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration
@ActiveProfiles("dev") <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indicate that the <code>dev</code> profile should be active.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example indicates that both the <code>dev</code> and the <code>integration</code> profiles should
be active:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration
@ActiveProfiles({"dev", "integration"}) <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indicate that the <code>dev</code> and <code>integration</code> profiles should be active.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration
@ActiveProfiles(["dev", "integration"]) <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indicate that the <code>dev</code> and <code>integration</code> profiles should be active.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@ActiveProfiles</code> provides support for inheriting active bean definition profiles
declared by superclasses by default. You can also resolve active bean definition profiles
programmatically by implementing a custom
<a href="#testcontext-ctx-management-env-profiles-ActiveProfilesResolver"><code>ActiveProfilesResolver</code></a>
and registering it by using the <code>resolver</code> attribute of <code>@ActiveProfiles</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="#testcontext-ctx-management-env-profiles">Context Configuration with Environment Profiles</a> and the
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/ActiveProfiles.html"><code>@ActiveProfiles</code></a> javadoc for
examples and further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-testpropertysource"><a class="anchor" href="#spring-testing-annotation-testpropertysource"></a><code>@TestPropertySource</code></h5>
<div class="paragraph">
<p><code>@TestPropertySource</code> is a class-level annotation that you can use to configure the
locations of properties files and inlined properties to be added to the set of
<code>PropertySources</code> in the <code>Environment</code> for an <code>ApplicationContext</code> loaded for an
integration test.</p>
</div>
<div class="paragraph">
<p>Test property sources have higher precedence than those loaded from the operating
system&#8217;s environment or Java system properties as well as property sources added by the
application declaratively through <code>@PropertySource</code> or programmatically. Thus, test
property sources can be used to selectively override properties defined in system and
application property sources. Furthermore, inlined properties have higher precedence than
properties loaded from resource locations.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates how to declare a properties file from the classpath:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get properties from <code>test.properties</code> in the root of the classpath.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get properties from <code>test.properties</code> in the root of the classpath.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example demonstrates how to declare inlined properties:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration
@TestPropertySource(properties = { "timezone = GMT", "port: 4242" }) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declare <code>timezone</code> and <code>port</code> properties.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration
@TestPropertySource(properties = ["timezone = GMT", "port: 4242"]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declare <code>timezone</code> and <code>port</code> properties.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="#testcontext-ctx-management-property-sources">Context Configuration with Test Property Sources</a> for examples and further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-dirtiescontext"><a class="anchor" href="#spring-testing-annotation-dirtiescontext"></a><code>@DirtiesContext</code></h5>
<div class="paragraph">
<p><code>@DirtiesContext</code> indicates that the underlying Spring <code>ApplicationContext</code> has been
dirtied during the execution of a test (that is, the test modified or corrupted it in
some manner&#8201;&#8212;&#8201;for example, by changing the state of a singleton bean) and should be
closed. When an application context is marked as dirty, it is removed from the testing
framework&#8217;s cache and closed. As a consequence, the underlying Spring container is
rebuilt for any subsequent test that requires a context with the same configuration
metadata.</p>
</div>
<div class="paragraph">
<p>You can use <code>@DirtiesContext</code> as both a class-level and a method-level annotation within
the same class or class hierarchy. In such scenarios, the <code>ApplicationContext</code> is marked
as dirty before or after any such annotated method as well as before or after the current
test class, depending on the configured <code>methodMode</code> and <code>classMode</code>.</p>
</div>
<div class="paragraph">
<p>The following examples explain when the context would be dirtied for various
configuration scenarios:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Before the current test class, when declared on a class with class mode set to
<code>BEFORE_CLASS</code>.</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@DirtiesContext(classMode = BEFORE_CLASS) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dirty the context before the current test class.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@DirtiesContext(classMode = BEFORE_CLASS) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dirty the context before the current test class.</td>
</tr>
</table>
</div>
</li>
<li>
<p>After the current test class, when declared on a class with class mode set to
<code>AFTER_CLASS</code> (i.e., the default class mode).</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dirty the context after the current test class.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dirty the context after the current test class.</td>
</tr>
</table>
</div>
</li>
<li>
<p>Before each test method in the current test class, when declared on a class with class
mode set to <code>BEFORE_EACH_TEST_METHOD.</code></p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dirty the context before each test method.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dirty the context before each test method.</td>
</tr>
</table>
</div>
</li>
<li>
<p>After each test method in the current test class, when declared on a class with class
mode set to <code>AFTER_EACH_TEST_METHOD.</code></p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dirty the context after each test method.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dirty the context after each test method.</td>
</tr>
</table>
</div>
</li>
<li>
<p>Before the current test, when declared on a method with the method mode set to
<code>BEFORE_METHOD</code>.</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@DirtiesContext(methodMode = BEFORE_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWhichRequiresFreshAppCtx() {
    // some logic that requires a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dirty the context before the current test method.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@DirtiesContext(methodMode = BEFORE_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichRequiresFreshAppCtx() {
    // some logic that requires a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dirty the context before the current test method.</td>
</tr>
</table>
</div>
</li>
<li>
<p>After the current test, when declared on a method with the method mode set to
<code>AFTER_METHOD</code> (i.e., the default method mode).</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWhichDirtiesAppCtx() {
    // some logic that results in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dirty the context after the current test method.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichDirtiesAppCtx() {
    // some logic that results in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Dirty the context after the current test method.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you use <code>@DirtiesContext</code> in a test whose context is configured as part of a context
hierarchy with <code>@ContextHierarchy</code>, you can use the <code>hierarchyMode</code> flag to control how
the context cache is cleared. By default, an exhaustive algorithm is used to clear the
context cache, including not only the current level but also all other context
hierarchies that share an ancestor context common to the current test. All
<code>ApplicationContext</code> instances that reside in a sub-hierarchy of the common ancestor
context are removed from the context cache and closed. If the exhaustive algorithm is
overkill for a particular use case, you can specify the simpler current level algorithm,
as the following example shows.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
class BaseTests {
    // class body...
}

class ExtendedTests extends BaseTests {

    @Test
    @DirtiesContext(hierarchyMode = CURRENT_LEVEL) <i class="conum" data-value="1"></i><b>(1)</b>
    void test() {
        // some logic that results in the child context being dirtied
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Use the current-level algorithm.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextHierarchy(
    ContextConfiguration("/parent-config.xml"),
    ContextConfiguration("/child-config.xml"))
open class BaseTests {
    // class body...
}

class ExtendedTests : BaseTests() {

    @Test
    @DirtiesContext(hierarchyMode = CURRENT_LEVEL) <i class="conum" data-value="1"></i><b>(1)</b>
    fun test() {
        // some logic that results in the child context being dirtied
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Use the current-level algorithm.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For further details regarding the <code>EXHAUSTIVE</code> and <code>CURRENT_LEVEL</code> algorithms, see the
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/annotation/DirtiesContext.HierarchyMode.html"><code>DirtiesContext.HierarchyMode</code></a>
javadoc.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-testexecutionlisteners"><a class="anchor" href="#spring-testing-annotation-testexecutionlisteners"></a><code>@TestExecutionListeners</code></h5>
<div class="paragraph">
<p><code>@TestExecutionListeners</code> defines class-level metadata for configuring the
<code>TestExecutionListener</code> implementations that should be registered with the
<code>TestContextManager</code>. Typically, <code>@TestExecutionListeners</code> is used in conjunction with
<code>@ContextConfiguration</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to register two <code>TestExecutionListener</code> implementations:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration
@TestExecutionListeners({CustomTestExecutionListener.class, AnotherTestExecutionListener.class}) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomTestExecutionListenerTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Register two <code>TestExecutionListener</code> implementations.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration
@TestExecutionListeners(CustomTestExecutionListener::class, AnotherTestExecutionListener::class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomTestExecutionListenerTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Register two <code>TestExecutionListener</code> implementations.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, <code>@TestExecutionListeners</code> supports inherited listeners. See the
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/TestExecutionListeners.html">javadoc</a>
for an example and further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-commit"><a class="anchor" href="#spring-testing-annotation-commit"></a><code>@Commit</code></h5>
<div class="paragraph">
<p><code>@Commit</code> indicates that the transaction for a transactional test method should be
committed after the test method has completed. You can use <code>@Commit</code> as a direct
replacement for <code>@Rollback(false)</code> to more explicitly convey the intent of the code.
Analogous to <code>@Rollback</code>, <code>@Commit</code> can also be declared as a class-level or method-level
annotation.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>@Commit</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Commit <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWithoutRollback() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Commit the result of the test to the database.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Commit <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWithoutRollback() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Commit the result of the test to the database.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-rollback"><a class="anchor" href="#spring-testing-annotation-rollback"></a><code>@Rollback</code></h5>
<div class="paragraph">
<p><code>@Rollback</code> indicates whether the transaction for a transactional test method should be
rolled back after the test method has completed. If <code>true</code>, the transaction is rolled
back. Otherwise, the transaction is committed (see also
<a href="#spring-testing-annotation-commit"><code>@Commit</code></a>). Rollback for integration tests in the Spring
TestContext Framework defaults to <code>true</code> even if <code>@Rollback</code> is not explicitly declared.</p>
</div>
<div class="paragraph">
<p>When declared as a class-level annotation, <code>@Rollback</code> defines the default rollback
semantics for all test methods within the test class hierarchy. When declared as a
method-level annotation, <code>@Rollback</code> defines rollback semantics for the specific test
method, potentially overriding class-level <code>@Rollback</code> or <code>@Commit</code> semantics.</p>
</div>
<div class="paragraph">
<p>The following example causes a test method&#8217;s result to not be rolled back (that is, the
result is committed to the database):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Rollback(false) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWithoutRollback() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Do not roll back the result.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Rollback(false) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWithoutRollback() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Do not roll back the result.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-beforetransaction"><a class="anchor" href="#spring-testing-annotation-beforetransaction"></a><code>@BeforeTransaction</code></h5>
<div class="paragraph">
<p><code>@BeforeTransaction</code> indicates that the annotated <code>void</code> method should be run before a
transaction is started, for test methods that have been configured to run within a
transaction by using Spring&#8217;s <code>@Transactional</code> annotation. <code>@BeforeTransaction</code> methods
are not required to be <code>public</code> and may be declared on Java 8-based interface default
methods.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>@BeforeTransaction</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@BeforeTransaction <i class="conum" data-value="1"></i><b>(1)</b>
void beforeTransaction() {
    // logic to be executed before a transaction is started
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Run this method before a transaction.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@BeforeTransaction <i class="conum" data-value="1"></i><b>(1)</b>
fun beforeTransaction() {
    // logic to be executed before a transaction is started
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Run this method before a transaction.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-aftertransaction"><a class="anchor" href="#spring-testing-annotation-aftertransaction"></a><code>@AfterTransaction</code></h5>
<div class="paragraph">
<p><code>@AfterTransaction</code> indicates that the annotated <code>void</code> method should be run after a
transaction is ended, for test methods that have been configured to run within a
transaction by using Spring&#8217;s <code>@Transactional</code> annotation. <code>@AfterTransaction</code> methods
are not required to be <code>public</code> and may be declared on Java 8-based interface default
methods.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AfterTransaction <i class="conum" data-value="1"></i><b>(1)</b>
void afterTransaction() {
    // logic to be executed after a transaction has ended
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Run this method after a transaction.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@AfterTransaction <i class="conum" data-value="1"></i><b>(1)</b>
fun afterTransaction() {
    // logic to be executed after a transaction has ended
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Run this method after a transaction.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sql"><a class="anchor" href="#spring-testing-annotation-sql"></a><code>@Sql</code></h5>
<div class="paragraph">
<p><code>@Sql</code> is used to annotate a test class or test method to configure SQL scripts to be run
against a given database during integration tests. The following example shows how to use
it:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@Sql({"/test-schema.sql", "/test-user-data.sql"}) <i class="conum" data-value="1"></i><b>(1)</b>
void userTest() {
    // execute code that relies on the test schema and test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Run two scripts for this test.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Test
@Sql("/test-schema.sql", "/test-user-data.sql") <i class="conum" data-value="1"></i><b>(1)</b>
fun userTest() {
    // execute code that relies on the test schema and test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Run two scripts for this test.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="#testcontext-executing-sql-declaratively">Executing SQL scripts declaratively with @Sql</a> for further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sqlconfig"><a class="anchor" href="#spring-testing-annotation-sqlconfig"></a><code>@SqlConfig</code></h5>
<div class="paragraph">
<p><code>@SqlConfig</code> defines metadata that is used to determine how to parse and run SQL scripts
configured with the <code>@Sql</code> annotation. The following example shows how to use it:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@Sql(
    scripts = "/test-user-data.sql",
    config = @SqlConfig(commentPrefix = "`", separator = "@@") <i class="conum" data-value="1"></i><b>(1)</b>
)
void userTest() {
    // execute code that relies on the test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the comment prefix and the separator in SQL scripts.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Test
@Sql("/test-user-data.sql", config = SqlConfig(commentPrefix = "`", separator = "@@")) <i class="conum" data-value="1"></i><b>(1)</b>
fun userTest() {
    // execute code that relies on the test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the comment prefix and the separator in SQL scripts.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sqlmergemode"><a class="anchor" href="#spring-testing-annotation-sqlmergemode"></a><code>@SqlMergeMode</code></h5>
<div class="paragraph">
<p><code>@SqlMergeMode</code> is used to annotate a test class or test method to configure whether
method-level <code>@Sql</code> declarations are merged with class-level <code>@Sql</code> declarations. If
<code>@SqlMergeMode</code> is not declared on a test class or test method, the <code>OVERRIDE</code> merge mode
will be used by default. With the <code>OVERRIDE</code> mode, method-level <code>@Sql</code> declarations will
effectively override class-level <code>@Sql</code> declarations.</p>
</div>
<div class="paragraph">
<p>Note that a method-level <code>@SqlMergeMode</code> declaration overrides a class-level declaration.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>@SqlMergeMode</code> at the class level.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig(TestConfig.class)
@Sql("/test-schema.sql")
@SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    void standardUserProfile() {
        // execute code that relies on test data set 001
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the <code>@Sql</code> merge mode to <code>MERGE</code> for all test methods in the class.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
@Sql("/test-schema.sql")
@SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    fun standardUserProfile() {
        // execute code that relies on test data set 001
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the <code>@Sql</code> merge mode to <code>MERGE</code> for all test methods in the class.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>@SqlMergeMode</code> at the method level.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig(TestConfig.class)
@Sql("/test-schema.sql")
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    @SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
    void standardUserProfile() {
        // execute code that relies on test data set 001
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the <code>@Sql</code> merge mode to <code>MERGE</code> for a specific test method.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
@Sql("/test-schema.sql")
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    @SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
    fun standardUserProfile() {
        // execute code that relies on test data set 001
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the <code>@Sql</code> merge mode to <code>MERGE</code> for a specific test method.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sqlgroup"><a class="anchor" href="#spring-testing-annotation-sqlgroup"></a><code>@SqlGroup</code></h5>
<div class="paragraph">
<p><code>@SqlGroup</code> is a container annotation that aggregates several <code>@Sql</code> annotations. You can
use <code>@SqlGroup</code> natively to declare several nested <code>@Sql</code> annotations, or you can use it
in conjunction with Java 8&#8217;s support for repeatable annotations, where <code>@Sql</code> can be
declared several times on the same class or method, implicitly generating this container
annotation. The following example shows how to declare an SQL group:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@SqlGroup({ <i class="conum" data-value="1"></i><b>(1)</b>
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}
void userTest() {
    // execute code that uses the test schema and test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declare a group of SQL scripts.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Test
@SqlGroup( <i class="conum" data-value="1"></i><b>(1)</b>
    Sql("/test-schema.sql", config = SqlConfig(commentPrefix = "`")),
    Sql("/test-user-data.sql"))
fun userTest() {
    // execute code that uses the test schema and test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declare a group of SQL scripts.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-standard"><a class="anchor" href="#integration-testing-annotations-standard"></a>3.4.2. Standard Annotation Support</h4>
<div class="paragraph">
<p>The following annotations are supported with standard semantics for all configurations of
the Spring TestContext Framework. Note that these annotations are not specific to tests
and can be used anywhere in the Spring Framework.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Autowired</code></p>
</li>
<li>
<p><code>@Qualifier</code></p>
</li>
<li>
<p><code>@Value</code></p>
</li>
<li>
<p><code>@Resource</code> (javax.annotation) if JSR-250 is present</p>
</li>
<li>
<p><code>@ManagedBean</code> (javax.annotation) if JSR-250 is present</p>
</li>
<li>
<p><code>@Inject</code> (javax.inject) if JSR-330 is present</p>
</li>
<li>
<p><code>@Named</code> (javax.inject) if JSR-330 is present</p>
</li>
<li>
<p><code>@PersistenceContext</code> (javax.persistence) if JPA is present</p>
</li>
<li>
<p><code>@PersistenceUnit</code> (javax.persistence) if JPA is present</p>
</li>
<li>
<p><code>@Required</code></p>
</li>
<li>
<p><code>@Transactional</code> (org.springframework.transaction.annotation)
<em>with <a href="#testcontext-tx-attribute-support">limited attribute support</a></em></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">JSR-250 Lifecycle Annotations</div>
<div class="paragraph">
<p>In the Spring TestContext Framework, you can use <code>@PostConstruct</code> and <code>@PreDestroy</code> with
standard semantics on any application components configured in the <code>ApplicationContext</code>.
However, these lifecycle annotations have limited usage within an actual test class.</p>
</div>
<div class="paragraph">
<p>If a method within a test class is annotated with <code>@PostConstruct</code>, that method runs
before any before methods of the underlying test framework (for example, methods
annotated with JUnit Jupiter&#8217;s <code>@BeforeEach</code>), and that applies for every test method in
the test class. On the other hand, if a method within a test class is annotated with
<code>@PreDestroy</code>, that method never runs. Therefore, within a test class, we recommend that
you use test lifecycle callbacks from the underlying test framework instead of
<code>@PostConstruct</code> and <code>@PreDestroy</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-junit4"><a class="anchor" href="#integration-testing-annotations-junit4"></a>3.4.3. Spring JUnit 4 Testing Annotations</h4>
<div class="paragraph">
<p>The following annotations are supported only when used in conjunction with the
<a href="#testcontext-junit4-runner">SpringRunner</a>, <a href="#testcontext-junit4-rules">Spring&#8217;s JUnit 4
rules</a>, or <a href="#testcontext-support-classes-junit4">Spring&#8217;s JUnit 4 support classes</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-annotations-junit4-ifprofilevalue"><code>@IfProfileValue</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"><code>@ProfileValueSourceConfiguration</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4-timed"><code>@Timed</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4-repeat"><code>@Repeat</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-ifprofilevalue"><a class="anchor" href="#integration-testing-annotations-junit4-ifprofilevalue"></a><code>@IfProfileValue</code></h5>
<div class="paragraph">
<p><code>@IfProfileValue</code> indicates that the annotated test is enabled for a specific testing
environment. If the configured <code>ProfileValueSource</code> returns a matching <code>value</code> for the
provided <code>name</code>, the test is enabled. Otherwise, the test is disabled and, effectively,
ignored.</p>
</div>
<div class="paragraph">
<p>You can apply <code>@IfProfileValue</code> at the class level, the method level, or both.
Class-level usage of <code>@IfProfileValue</code> takes precedence over method-level usage for any
methods within that class or its subclasses. Specifically, a test is enabled if it is
enabled both at the class level and at the method level. The absence of <code>@IfProfileValue</code>
means the test is implicitly enabled. This is analogous to the semantics of JUnit 4&#8217;s
<code>@Ignore</code> annotation, except that the presence of <code>@Ignore</code> always disables a test.</p>
</div>
<div class="paragraph">
<p>The following example shows a test that has an <code>@IfProfileValue</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@IfProfileValue(name="java.vendor", value="Oracle Corporation") <i class="conum" data-value="1"></i><b>(1)</b>
@Test
public void testProcessWhichRunsOnlyOnOracleJvm() {
    // some logic that should run only on Java VMs from Oracle Corporation
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Run this test only when the Java vendor is "Oracle Corporation".</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@IfProfileValue(name="java.vendor", value="Oracle Corporation") <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichRunsOnlyOnOracleJvm() {
    // some logic that should run only on Java VMs from Oracle Corporation
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Run this test only when the Java vendor is "Oracle Corporation".</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, you can configure <code>@IfProfileValue</code> with a list of <code>values</code> (with <code>OR</code>
semantics) to achieve TestNG-like support for test groups in a JUnit 4 environment.
Consider the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@IfProfileValue(name="test-groups", values={"unit-tests", "integration-tests"}) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
public void testProcessWhichRunsForUnitOrIntegrationTestGroups() {
    // some logic that should run only for unit and integration test groups
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Run this test for unit tests and integration tests.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@IfProfileValue(name="test-groups", values=["unit-tests", "integration-tests"]) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichRunsForUnitOrIntegrationTestGroups() {
    // some logic that should run only for unit and integration test groups
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Run this test for unit tests and integration tests.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-profilevaluesourceconfiguration"><a class="anchor" href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"></a><code>@ProfileValueSourceConfiguration</code></h5>
<div class="paragraph">
<p><code>@ProfileValueSourceConfiguration</code> is a class-level annotation that specifies what type
of <code>ProfileValueSource</code> to use when retrieving profile values configured through the
<code>@IfProfileValue</code> annotation. If <code>@ProfileValueSourceConfiguration</code> is not declared for a
test, <code>SystemProfileValueSource</code> is used by default. The following example shows how to
use <code>@ProfileValueSourceConfiguration</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ProfileValueSourceConfiguration(CustomProfileValueSource.class) <i class="conum" data-value="1"></i><b>(1)</b>
public class CustomProfileValueSourceTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Use a custom profile value source.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ProfileValueSourceConfiguration(CustomProfileValueSource::class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomProfileValueSourceTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Use a custom profile value source.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-timed"><a class="anchor" href="#integration-testing-annotations-junit4-timed"></a><code>@Timed</code></h5>
<div class="paragraph">
<p><code>@Timed</code> indicates that the annotated test method must finish execution in a specified
time period (in milliseconds). If the text execution time exceeds the specified time
period, the test fails.</p>
</div>
<div class="paragraph">
<p>The time period includes running the test method itself, any repetitions of the test (see
<code>@Repeat</code>), as well as any setting up or tearing down of the test fixture. The following
example shows how to use it:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Timed(millis = 1000) <i class="conum" data-value="1"></i><b>(1)</b>
public void testProcessWithOneSecondTimeout() {
    // some logic that should not take longer than 1 second to execute
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the time period for the test to one second.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Timed(millis = 1000) <i class="conum" data-value="1"></i><b>(1)</b>
fun testProcessWithOneSecondTimeout() {
    // some logic that should not take longer than 1 second to execute
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the time period for the test to one second.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring&#8217;s <code>@Timed</code> annotation has different semantics than JUnit 4&#8217;s <code>@Test(timeout=&#8230;&#8203;)</code>
support. Specifically, due to the manner in which JUnit 4 handles test execution timeouts
(that is, by executing the test method in a separate <code>Thread</code>), <code>@Test(timeout=&#8230;&#8203;)</code>
preemptively fails the test if the test takes too long. Spring&#8217;s <code>@Timed</code>, on the other
hand, does not preemptively fail the test but rather waits for the test to complete
before failing.</p>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-repeat"><a class="anchor" href="#integration-testing-annotations-junit4-repeat"></a><code>@Repeat</code></h5>
<div class="paragraph">
<p><code>@Repeat</code> indicates that the annotated test method must be run repeatedly. The number of
times that the test method is to be executed is specified in the annotation.</p>
</div>
<div class="paragraph">
<p>The scope of execution to be repeated includes execution of the test method itself as
well as any setting up or tearing down of the test fixture. The following example shows
how to use the <code>@Repeat</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Repeat(10) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
public void testProcessRepeatedly() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Repeat this test ten times.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Repeat(10) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessRepeatedly() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Repeat this test ten times.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-junit-jupiter"><a class="anchor" href="#integration-testing-annotations-junit-jupiter"></a>3.4.4. Spring JUnit Jupiter Testing Annotations</h4>
<div class="paragraph">
<p>The following annotations are supported only when used in conjunction with the
<a href="#testcontext-junit-jupiter-extension"><code>SpringExtension</code></a> and JUnit Jupiter
(that is, the programming model in JUnit 5):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-springjunitconfig"><code>@SpringJUnitConfig</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"><code>@SpringJUnitWebConfig</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-enabledif"><code>@EnabledIf</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-disabledif"><code>@DisabledIf</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-springjunitconfig"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-springjunitconfig"></a><code>@SpringJUnitConfig</code></h5>
<div class="paragraph">
<p><code>@SpringJUnitConfig</code> is a composed annotation that combines
<code>@ExtendWith(SpringExtension.class)</code> from JUnit Jupiter with <code>@ContextConfiguration</code> from
the Spring TestContext Framework. It can be used at the class level as a drop-in
replacement for <code>@ContextConfiguration</code>. With regard to configuration options, the only
difference between <code>@ContextConfiguration</code> and <code>@SpringJUnitConfig</code> is that component
classes may be declared with the <code>value</code> attribute in <code>@SpringJUnitConfig</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>@SpringJUnitConfig</code> annotation to specify a
configuration class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig(TestConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify the configuration class.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify the configuration class.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>@SpringJUnitConfig</code> annotation to specify the
location of a configuration file:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig(locations = "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify the location of a configuration file.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(locations = ["/test-config.xml"]) <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify the location of a configuration file.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="#testcontext-ctx-management">Context Management</a> as well as the javadoc for
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/junit/jupiter/SpringJUnitConfig.html"><code>@SpringJUnitConfig</code></a>
and <code>@ContextConfiguration</code> for further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-springjunitwebconfig"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"></a><code>@SpringJUnitWebConfig</code></h5>
<div class="paragraph">
<p><code>@SpringJUnitWebConfig</code> is a composed annotation that combines
<code>@ExtendWith(SpringExtension.class)</code> from JUnit Jupiter with <code>@ContextConfiguration</code> and
<code>@WebAppConfiguration</code> from the Spring TestContext Framework. You can use it at the class
level as a drop-in replacement for <code>@ContextConfiguration</code> and <code>@WebAppConfiguration</code>.
With regard to configuration options, the only difference between <code>@ContextConfiguration</code>
and <code>@SpringJUnitWebConfig</code> is that you can declare component classes by using the
<code>value</code> attribute in <code>@SpringJUnitWebConfig</code>. In addition, you can override the <code>value</code>
attribute from <code>@WebAppConfiguration</code> only by using the <code>resourcePath</code> attribute in
<code>@SpringJUnitWebConfig</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>@SpringJUnitWebConfig</code> annotation to specify
a configuration class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitWebConfig(TestConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify the configuration class.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitWebConfig(TestConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify the configuration class.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to use the <code>@SpringJUnitWebConfig</code> annotation to specify the
location of a configuration file:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitWebConfig(locations = "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify the location of a configuration file.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitWebConfig(locations = ["/test-config.xml"]) <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify the location of a configuration file.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="#testcontext-ctx-management">Context Management</a> as well as the javadoc for
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/junit/jupiter/web/SpringJUnitWebConfig.html"><code>@SpringJUnitWebConfig</code></a>,
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/ContextConfiguration.html"><code>@ContextConfiguration</code></a>, and
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html"><code>@WebAppConfiguration</code></a>
for further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-testconstructor"><a class="anchor" href="#integration-testing-annotations-testconstructor"></a><code>@TestConstructor</code></h5>
<div class="paragraph">
<p><code>@TestConstructor</code> is a type-level annotation that is used to configure how the parameters
of a test class constructor are autowired from components in the test&#8217;s
<code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>If <code>@TestConstructor</code> is not present or meta-present on a test class, the default <em>test
constructor autowire mode</em> will be used. See the tip below for details on how to change
the default mode. Note, however, that a local declaration of <code>@Autowired</code> on a
constructor takes precedence over both <code>@TestConstructor</code> and the default mode.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Changing the default test constructor autowire mode</div>
<div class="paragraph">
<p>The default <em>test constructor autowire mode</em> can be changed by setting the
<code>spring.test.constructor.autowire.mode</code> JVM system property to <code>all</code>. Alternatively, the
default mode may be changed via the <code>SpringProperties</code> mechanism.</p>
</div>
<div class="paragraph">
<p>If the <code>spring.test.constructor.autowire.mode</code> property is not set, test class
constructors will not be automatically autowired.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As of Spring Framework 5.2, <code>@TestConstructor</code> is only supported in conjunction
with the <code>SpringExtension</code> for use with JUnit Jupiter. Note that the <code>SpringExtension</code> is
often automatically registered for you – for example, when using annotations such as
<code>@SpringJUnitConfig</code> and <code>@SpringJUnitWebConfig</code> or various test-related annotations from
Spring Boot Test.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-enabledif"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-enabledif"></a><code>@EnabledIf</code></h5>
<div class="paragraph">
<p><code>@EnabledIf</code> is used to signal that the annotated JUnit Jupiter test class or test method
is enabled and should be run if the supplied <code>expression</code> evaluates to <code>true</code>.
Specifically, if the expression evaluates to <code>Boolean.TRUE</code> or a <code>String</code> equal to <code>true</code>
(ignoring case), the test is enabled. When applied at the class level, all test methods
within that class are automatically enabled by default as well.</p>
</div>
<div class="paragraph">
<p>Expressions can be any of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="core.html#expressions">Spring Expression Language</a> (SpEL) expression. For example:
<code>@EnabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")</code></p>
</li>
<li>
<p>Placeholder for a property available in the Spring <a href="core.html#beans-environment"><code>Environment</code></a>.
For example: <code>@EnabledIf("${smoke.tests.enabled}")</code></p>
</li>
<li>
<p>Text literal. For example: <code>@EnabledIf("true")</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note, however, that a text literal that is not the result of dynamic resolution of a
property placeholder is of zero practical value, since <code>@EnabledIf("false")</code> is
equivalent to <code>@Disabled</code> and <code>@EnabledIf("true")</code> is logically meaningless.</p>
</div>
<div class="paragraph">
<p>You can use <code>@EnabledIf</code> as a meta-annotation to create custom composed annotations. For
example, you can create a custom <code>@EnabledOnMac</code> annotation as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@EnabledIf(
    expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
    reason = "Enabled on Mac OS"
)
public @interface EnabledOnMac {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@EnabledIf(
        expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
        reason = "Enabled on Mac OS"
)
annotation class EnabledOnMac {}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-disabledif"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-disabledif"></a><code>@DisabledIf</code></h5>
<div class="paragraph">
<p><code>@DisabledIf</code> is used to signal that the annotated JUnit Jupiter test class or test
method is disabled and should not be executed if the supplied <code>expression</code> evaluates to
<code>true</code>. Specifically, if the expression evaluates to <code>Boolean.TRUE</code> or a <code>String</code> equal
to <code>true</code> (ignoring case), the test is disabled. When applied at the class level, all
test methods within that class are automatically disabled as well.</p>
</div>
<div class="paragraph">
<p>Expressions can be any of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="core.html#expressions">Spring Expression Language</a> (SpEL) expression. For example:
<code>@DisabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")</code></p>
</li>
<li>
<p>Placeholder for a property available in the Spring <a href="core.html#beans-environment"><code>Environment</code></a>.
For example: <code>@DisabledIf("${smoke.tests.disabled}")</code></p>
</li>
<li>
<p>Text literal. For example: <code>@DisabledIf("true")</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note, however, that a text literal that is not the result of dynamic resolution of a
property placeholder is of zero practical value, since <code>@DisabledIf("true")</code> is
equivalent to <code>@Disabled</code> and <code>@DisabledIf("false")</code> is logically meaningless.</p>
</div>
<div class="paragraph">
<p>You can use <code>@DisabledIf</code> as a meta-annotation to create custom composed annotations. For
example, you can create a custom <code>@DisabledOnMac</code> annotation as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@DisabledIf(
    expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
    reason = "Disabled on Mac OS"
)
public @interface DisabledOnMac {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@DisabledIf(
        expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
        reason = "Disabled on Mac OS"
)
annotation class DisabledOnMac {}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-meta"><a class="anchor" href="#integration-testing-annotations-meta"></a>3.4.5. Meta-Annotation Support for Testing</h4>
<div class="paragraph">
<p>You can use most test-related annotations as
<a href="core.html#beans-meta-annotations">meta-annotations</a> to create custom composed
annotations and reduce configuration duplication across a test suite.</p>
</div>
<div class="paragraph">
<p>You can use each of the following as a meta-annotation in conjunction with the
<a href="#testcontext-framework">TestContext framework</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@BootstrapWith</code></p>
</li>
<li>
<p><code>@ContextConfiguration</code></p>
</li>
<li>
<p><code>@ContextHierarchy</code></p>
</li>
<li>
<p><code>@ActiveProfiles</code></p>
</li>
<li>
<p><code>@TestPropertySource</code></p>
</li>
<li>
<p><code>@DirtiesContext</code></p>
</li>
<li>
<p><code>@WebAppConfiguration</code></p>
</li>
<li>
<p><code>@TestExecutionListeners</code></p>
</li>
<li>
<p><code>@Transactional</code></p>
</li>
<li>
<p><code>@BeforeTransaction</code></p>
</li>
<li>
<p><code>@AfterTransaction</code></p>
</li>
<li>
<p><code>@Commit</code></p>
</li>
<li>
<p><code>@Rollback</code></p>
</li>
<li>
<p><code>@Sql</code></p>
</li>
<li>
<p><code>@SqlConfig</code></p>
</li>
<li>
<p><code>@SqlMergeMode</code></p>
</li>
<li>
<p><code>@SqlGroup</code></p>
</li>
<li>
<p><code>@Repeat</code> <em>(only supported on JUnit 4)</em></p>
</li>
<li>
<p><code>@Timed</code> <em>(only supported on JUnit 4)</em></p>
</li>
<li>
<p><code>@IfProfileValue</code> <em>(only supported on JUnit 4)</em></p>
</li>
<li>
<p><code>@ProfileValueSourceConfiguration</code> <em>(only supported on JUnit 4)</em></p>
</li>
<li>
<p><code>@SpringJUnitConfig</code> <em>(only supported on JUnit Jupiter)</em></p>
</li>
<li>
<p><code>@SpringJUnitWebConfig</code> <em>(only supported on JUnit Jupiter)</em></p>
</li>
<li>
<p><code>@TestConstructor</code> <em>(only supported on JUnit Jupiter)</em></p>
</li>
<li>
<p><code>@EnabledIf</code> <em>(only supported on JUnit Jupiter)</em></p>
</li>
<li>
<p><code>@DisabledIf</code> <em>(only supported on JUnit Jupiter)</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public class OrderRepositoryTests { }

@RunWith(SpringRunner.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@RunWith(SpringRunner::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class OrderRepositoryTests { }

@RunWith(SpringRunner::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we discover that we are repeating the preceding configuration across our JUnit 4-based
test suite, we can reduce the duplication by introducing a custom composed annotation
that centralizes the common test configuration for Spring, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public @interface TransactionalDevTestConfig { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
annotation class TransactionalDevTestConfig { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we can use our custom <code>@TransactionalDevTestConfig</code> annotation to simplify the
configuration of individual JUnit 4 based test classes, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class OrderRepositoryTests { }

@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@RunWith(SpringRunner::class)
@TransactionalDevTestConfig
class OrderRepositoryTests

@RunWith(SpringRunner::class)
@TransactionalDevTestConfig
class UserRepositoryTests</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we write tests that use JUnit Jupiter, we can reduce code duplication even further,
since annotations in JUnit 5 can also be used as meta-annotations. Consider the following
example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
class OrderRepositoryTests { }

@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class OrderRepositoryTests { }

@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we discover that we are repeating the preceding configuration across our JUnit
Jupiter-based test suite, we can reduce the duplication by introducing a custom composed
annotation that centralizes the common test configuration for Spring and JUnit Jupiter,
as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public @interface TransactionalDevTestConfig { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
annotation class TransactionalDevTestConfig { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we can use our custom <code>@TransactionalDevTestConfig</code> annotation to simplify the
configuration of individual JUnit Jupiter based test classes, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TransactionalDevTestConfig
class OrderRepositoryTests { }

@TransactionalDevTestConfig
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@TransactionalDevTestConfig
class OrderRepositoryTests { }

@TransactionalDevTestConfig
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since JUnit Jupiter supports the use of <code>@Test</code>, <code>@RepeatedTest</code>, <code>ParameterizedTest</code>,
and others as meta-annotations, you can also create custom composed annotations at the
test method level. For example, if we wish to create a composed annotation that combines
the <code>@Test</code> and <code>@Tag</code> annotations from JUnit Jupiter with the <code>@Transactional</code>
annotation from Spring, we could create an <code>@TransactionalIntegrationTest</code> annotation, as
follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Transactional
@Tag("integration-test") // org.junit.jupiter.api.Tag
@Test // org.junit.jupiter.api.Test
public @interface TransactionalIntegrationTest { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@Transactional
@Tag("integration-test") // org.junit.jupiter.api.Tag
@Test // org.junit.jupiter.api.Test
annotation class TransactionalIntegrationTest { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we can use our custom <code>@TransactionalIntegrationTest</code> annotation to simplify the
configuration of individual JUnit Jupiter based test methods, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TransactionalIntegrationTest
void saveOrder() { }

@TransactionalIntegrationTest
void deleteOrder() { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@TransactionalIntegrationTest
fun saveOrder() { }

@TransactionalIntegrationTest
fun deleteOrder() { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>For further details, see the
<a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring Annotation Programming Model</a>
wiki page.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testcontext-framework"><a class="anchor" href="#testcontext-framework"></a>3.5. Spring TestContext Framework</h3>
<div class="paragraph">
<p>The Spring TestContext Framework (located in the <code>org.springframework.test.context</code>
package) provides generic, annotation-driven unit and integration testing support that is
agnostic of the testing framework in use. The TestContext framework also places a great
deal of importance on convention over configuration, with reasonable defaults that you
can override through annotation-based configuration.</p>
</div>
<div class="paragraph">
<p>In addition to generic testing infrastructure, the TestContext framework provides
explicit support for JUnit 4, JUnit Jupiter (AKA JUnit 5), and TestNG. For JUnit 4 and
TestNG, Spring provides <code>abstract</code> support classes. Furthermore, Spring provides a custom
JUnit <code>Runner</code> and custom JUnit <code>Rules</code> for JUnit 4 and a custom <code>Extension</code> for JUnit
Jupiter that let you write so-called POJO test classes. POJO test classes are not
required to extend a particular class hierarchy, such as the <code>abstract</code> support classes.</p>
</div>
<div class="paragraph">
<p>The following section provides an overview of the internals of the TestContext framework.
If you are interested only in using the framework and are not interested in extending it
with your own custom listeners or custom loaders, feel free to go directly to the
configuration (<a href="#testcontext-ctx-management">context management</a>,
<a href="#testcontext-fixture-di">dependency injection</a>, <a href="#testcontext-tx">transaction
management</a>), <a href="#testcontext-support-classes">support classes</a>, and
<a href="#integration-testing-annotations">annotation support</a> sections.</p>
</div>
<div class="sect3">
<h4 id="testcontext-key-abstractions"><a class="anchor" href="#testcontext-key-abstractions"></a>3.5.1. Key Abstractions</h4>
<div class="paragraph">
<p>The core of the framework consists of the <code>TestContextManager</code> class and the
<code>TestContext</code>, <code>TestExecutionListener</code>, and <code>SmartContextLoader</code> interfaces. A
<code>TestContextManager</code> is created for each test class (for example, for the execution of
all test methods within a single test class in JUnit Jupiter). The <code>TestContextManager</code>,
in turn, manages a <code>TestContext</code> that holds the context of the current test. The
<code>TestContextManager</code> also updates the state of the <code>TestContext</code> as the test progresses
and delegates to <code>TestExecutionListener</code> implementations, which instrument the actual
test execution by providing dependency injection, managing transactions, and so on. A
<code>SmartContextLoader</code> is responsible for loading an <code>ApplicationContext</code> for a given test
class. See the <a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/package-summary.html">javadoc</a> and the
Spring test suite for further information and examples of various implementations.</p>
</div>
<div class="sect4">
<h5 id="testcontext"><a class="anchor" href="#testcontext"></a><code>TestContext</code></h5>
<div class="paragraph">
<p><code>TestContext</code> encapsulates the context in which a test is executed (agnostic of the
actual testing framework in use) and provides context management and caching support for
the test instance for which it is responsible. The <code>TestContext</code> also delegates to a
<code>SmartContextLoader</code> to load an <code>ApplicationContext</code> if requested.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontextmanager"><a class="anchor" href="#testcontextmanager"></a><code>TestContextManager</code></h5>
<div class="paragraph">
<p><code>TestContextManager</code> is the main entry point into the Spring TestContext Framework and is
responsible for managing a single <code>TestContext</code> and signaling events to each registered
<code>TestExecutionListener</code> at well-defined test execution points:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Prior to any &#8220;before class&#8221; or &#8220;before all&#8221; methods of a particular testing framework.</p>
</li>
<li>
<p>Test instance post-processing.</p>
</li>
<li>
<p>Prior to any &#8220;before&#8221; or &#8220;before each&#8221; methods of a particular testing framework.</p>
</li>
<li>
<p>Immediately before execution of the test method but after test setup.</p>
</li>
<li>
<p>Immediately after execution of the test method but before test tear down.</p>
</li>
<li>
<p>After any &#8220;after&#8221; or &#8220;after each&#8221; methods of a particular testing framework.</p>
</li>
<li>
<p>After any &#8220;after class&#8221; or &#8220;after all&#8221; methods of a particular testing framework.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="testexecutionlistener"><a class="anchor" href="#testexecutionlistener"></a><code>TestExecutionListener</code></h5>
<div class="paragraph">
<p><code>TestExecutionListener</code> defines the API for reacting to test-execution events published by
the <code>TestContextManager</code> with which the listener is registered. See <a href="#testcontext-tel-config"><code>TestExecutionListener</code> Configuration</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="context-loaders"><a class="anchor" href="#context-loaders"></a>Context Loaders</h5>
<div class="paragraph">
<p><code>ContextLoader</code> is a strategy interface for loading an <code>ApplicationContext</code> for an
integration test managed by the Spring TestContext Framework. You should implement
<code>SmartContextLoader</code> instead of this interface to provide support for component classes,
active bean definition profiles, test property sources, context hierarchies, and
<code>WebApplicationContext</code> support.</p>
</div>
<div class="paragraph">
<p><code>SmartContextLoader</code> is an extension of the <code>ContextLoader</code> interface that supersedes the
original minimal <code>ContextLoader</code> SPI. Specifically, a <code>SmartContextLoader</code> can choose to
process resource locations, component classes, or context initializers. Furthermore, a
<code>SmartContextLoader</code> can set active bean definition profiles and test property sources in
the context that it loads.</p>
</div>
<div class="paragraph">
<p>Spring provides the following implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DelegatingSmartContextLoader</code>: One of two default loaders, it delegates internally to
an <code>AnnotationConfigContextLoader</code>, a <code>GenericXmlContextLoader</code>, or a
<code>GenericGroovyXmlContextLoader</code>, depending either on the configuration declared for the
test class or on the presence of default locations or default configuration classes.
Groovy support is enabled only if Groovy is on the classpath.</p>
</li>
<li>
<p><code>WebDelegatingSmartContextLoader</code>: One of two default loaders, it delegates internally
to an <code>AnnotationConfigWebContextLoader</code>, a <code>GenericXmlWebContextLoader</code>, or a
<code>GenericGroovyXmlWebContextLoader</code>, depending either on the configuration declared for
the test class or on the presence of default locations or default configuration
classes. A web <code>ContextLoader</code> is used only if <code>@WebAppConfiguration</code> is present on the
test class. Groovy support is enabled only if Groovy is on the classpath.</p>
</li>
<li>
<p><code>AnnotationConfigContextLoader</code>: Loads a standard <code>ApplicationContext</code> from component
classes.</p>
</li>
<li>
<p><code>AnnotationConfigWebContextLoader</code>: Loads a <code>WebApplicationContext</code> from component
classes.</p>
</li>
<li>
<p><code>GenericGroovyXmlContextLoader</code>: Loads a standard <code>ApplicationContext</code> from resource
locations that are either Groovy scripts or XML configuration files.</p>
</li>
<li>
<p><code>GenericGroovyXmlWebContextLoader</code>: Loads a <code>WebApplicationContext</code> from resource
locations that are either Groovy scripts or XML configuration files.</p>
</li>
<li>
<p><code>GenericXmlContextLoader</code>: Loads a standard <code>ApplicationContext</code> from XML resource
locations.</p>
</li>
<li>
<p><code>GenericXmlWebContextLoader</code>: Loads a <code>WebApplicationContext</code> from XML resource
locations.</p>
</li>
<li>
<p><code>GenericPropertiesContextLoader</code>: Loads a standard <code>ApplicationContext</code> from Java
properties files.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-bootstrapping"><a class="anchor" href="#testcontext-bootstrapping"></a>3.5.2. Bootstrapping the TestContext Framework</h4>
<div class="paragraph">
<p>The default configuration for the internals of the Spring TestContext Framework is
sufficient for all common use cases. However, there are times when a development team or
third party framework would like to change the default <code>ContextLoader</code>, implement a
custom <code>TestContext</code> or <code>ContextCache</code>, augment the default sets of
<code>ContextCustomizerFactory</code> and <code>TestExecutionListener</code> implementations, and so on. For
such low-level control over how the TestContext framework operates, Spring provides a
bootstrapping strategy.</p>
</div>
<div class="paragraph">
<p><code>TestContextBootstrapper</code> defines the SPI for bootstrapping the TestContext framework. A
<code>TestContextBootstrapper</code> is used by the <code>TestContextManager</code> to load the
<code>TestExecutionListener</code> implementations for the current test and to build the
<code>TestContext</code> that it manages. You can configure a custom bootstrapping strategy for a
test class (or test class hierarchy) by using <code>@BootstrapWith</code>, either directly or as a
meta-annotation. If a bootstrapper is not explicitly configured by using
<code>@BootstrapWith</code>, either the <code>DefaultTestContextBootstrapper</code> or the
<code>WebTestContextBootstrapper</code> is used, depending on the presence of <code>@WebAppConfiguration</code>.</p>
</div>
<div class="paragraph">
<p>Since the <code>TestContextBootstrapper</code> SPI is likely to change in the future (to accommodate
new requirements), we strongly encourage implementers not to implement this interface
directly but rather to extend <code>AbstractTestContextBootstrapper</code> or one of its concrete
subclasses instead.</p>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-tel-config"><a class="anchor" href="#testcontext-tel-config"></a>3.5.3. <code>TestExecutionListener</code> Configuration</h4>
<div class="paragraph">
<p>Spring provides the following <code>TestExecutionListener</code> implementations that are registered
by default, exactly in the following order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ServletTestExecutionListener</code>: Configures Servlet API mocks for a
<code>WebApplicationContext</code>.</p>
</li>
<li>
<p><code>DirtiesContextBeforeModesTestExecutionListener</code>: Handles the <code>@DirtiesContext</code>
annotation for &#8220;before&#8221; modes.</p>
</li>
<li>
<p><code>DependencyInjectionTestExecutionListener</code>: Provides dependency injection for the test
instance.</p>
</li>
<li>
<p><code>DirtiesContextTestExecutionListener</code>: Handles the <code>@DirtiesContext</code> annotation for
&#8220;after&#8221; modes.</p>
</li>
<li>
<p><code>TransactionalTestExecutionListener</code>: Provides transactional test execution with
default rollback semantics.</p>
</li>
<li>
<p><code>SqlScriptsTestExecutionListener</code>: Runs SQL scripts configured by using the <code>@Sql</code>
annotation.</p>
</li>
<li>
<p><code>EventPublishingTestExecutionListener</code>: Publishes test execution events to the test&#8217;s
<code>ApplicationContext</code> (see <a href="#testcontext-test-execution-events">Test Execution Events</a>).</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-registering-tels"><a class="anchor" href="#testcontext-tel-config-registering-tels"></a>Registering <code>TestExecutionListener</code> Implementations</h5>
<div class="paragraph">
<p>You can register <code>TestExecutionListener</code> implementations for a test class and its
subclasses by using the <code>@TestExecutionListeners</code> annotation. See
<a href="#integration-testing-annotations">annotation support</a> and the javadoc for
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/TestExecutionListeners.html"><code>@TestExecutionListeners</code></a>
for details and examples.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-automatic-discovery"><a class="anchor" href="#testcontext-tel-config-automatic-discovery"></a>Automatic Discovery of Default <code>TestExecutionListener</code> Implementations</h5>
<div class="paragraph">
<p>Registering <code>TestExecutionListener</code> implementations by using <code>@TestExecutionListeners</code> is
suitable for custom listeners that are used in limited testing scenarios. However, it can
become cumbersome if a custom listener needs to be used across an entire test suite. This
issue is addressed through support for automatic discovery of default
<code>TestExecutionListener</code> implementations through the <code>SpringFactoriesLoader</code> mechanism.</p>
</div>
<div class="paragraph">
<p>Specifically, the <code>spring-test</code> module declares all core default <code>TestExecutionListener</code>
implementations under the <code>org.springframework.test.context.TestExecutionListener</code> key in
its <code>META-INF/spring.factories</code> properties file. Third-party frameworks and developers
can contribute their own <code>TestExecutionListener</code> implementations to the list of default
listeners in the same manner through their own <code>META-INF/spring.factories</code> properties
file.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-ordering"><a class="anchor" href="#testcontext-tel-config-ordering"></a>Ordering <code>TestExecutionListener</code> Implementations</h5>
<div class="paragraph">
<p>When the TestContext framework discovers default <code>TestExecutionListener</code> implementations
through the <a href="#testcontext-tel-config-automatic-discovery">aforementioned</a>
<code>SpringFactoriesLoader</code> mechanism, the instantiated listeners are sorted by using
Spring&#8217;s <code>AnnotationAwareOrderComparator</code>, which honors Spring&#8217;s <code>Ordered</code> interface and
<code>@Order</code> annotation for ordering. <code>AbstractTestExecutionListener</code> and all default
<code>TestExecutionListener</code> implementations provided by Spring implement <code>Ordered</code> with
appropriate values. Third-party frameworks and developers should therefore make sure that
their default <code>TestExecutionListener</code> implementations are registered in the proper order
by implementing <code>Ordered</code> or declaring <code>@Order</code>. See the javadoc for the <code>getOrder()</code>
methods of the core default <code>TestExecutionListener</code> implementations for details on what
values are assigned to each core listener.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-merging"><a class="anchor" href="#testcontext-tel-config-merging"></a>Merging <code>TestExecutionListener</code> Implementations</h5>
<div class="paragraph">
<p>If a custom <code>TestExecutionListener</code> is registered via <code>@TestExecutionListeners</code>, the
default listeners are not registered. In most common testing scenarios, this effectively
forces the developer to manually declare all default listeners in addition to any custom
listeners. The following listing demonstrates this style of configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration
@TestExecutionListeners({
    MyCustomTestExecutionListener.class,
    ServletTestExecutionListener.class,
    DirtiesContextBeforeModesTestExecutionListener.class,
    DependencyInjectionTestExecutionListener.class,
    DirtiesContextTestExecutionListener.class,
    TransactionalTestExecutionListener.class,
    SqlScriptsTestExecutionListener.class
})
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration
@TestExecutionListeners(
    MyCustomTestExecutionListener::class,
    ServletTestExecutionListener::class,
    DirtiesContextBeforeModesTestExecutionListener::class,
    DependencyInjectionTestExecutionListener::class,
    DirtiesContextTestExecutionListener::class,
    TransactionalTestExecutionListener::class,
    SqlScriptsTestExecutionListener::class
)
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The challenge with this approach is that it requires that the developer know exactly
which listeners are registered by default. Moreover, the set of default listeners can
change from release to release&#8201;&#8212;&#8201;for example, <code>SqlScriptsTestExecutionListener</code> was
introduced in Spring Framework 4.1, and <code>DirtiesContextBeforeModesTestExecutionListener</code>
was introduced in Spring Framework 4.2. Furthermore, third-party frameworks like Spring
Boot and Spring Security register their own default <code>TestExecutionListener</code>
implementations by using the aforementioned <a href="#testcontext-tel-config-automatic-discovery">automatic discovery mechanism</a>.</p>
</div>
<div class="paragraph">
<p>To avoid having to be aware of and re-declare all default listeners, you can set the
<code>mergeMode</code> attribute of <code>@TestExecutionListeners</code> to <code>MergeMode.MERGE_WITH_DEFAULTS</code>.
<code>MERGE_WITH_DEFAULTS</code> indicates that locally declared listeners should be merged with the
default listeners. The merging algorithm ensures that duplicates are removed from the
list and that the resulting set of merged listeners is sorted according to the semantics
of <code>AnnotationAwareOrderComparator</code>, as described in <a href="#testcontext-tel-config-ordering">Ordering <code>TestExecutionListener</code> Implementations</a>.
If a listener implements <code>Ordered</code> or is annotated with <code>@Order</code>, it can influence the
position in which it is merged with the defaults. Otherwise, locally declared listeners
are appended to the list of default listeners when merged.</p>
</div>
<div class="paragraph">
<p>For example, if the <code>MyCustomTestExecutionListener</code> class in the previous example
configures its <code>order</code> value (for example, <code>500</code>) to be less than the order of the
<code>ServletTestExecutionListener</code> (which happens to be <code>1000</code>), the
<code>MyCustomTestExecutionListener</code> can then be automatically merged with the list of
defaults in front of the <code>ServletTestExecutionListener</code>, and the previous example could
be replaced with the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration
@TestExecutionListeners(
    listeners = MyCustomTestExecutionListener.class,
    mergeMode = MERGE_WITH_DEFAULTS
)
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration
@TestExecutionListeners(
        listeners = [MyCustomTestExecutionListener::class],
        mergeMode = MERGE_WITH_DEFAULTS
)
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-test-execution-events"><a class="anchor" href="#testcontext-test-execution-events"></a>3.5.4. Test Execution Events</h4>
<div class="paragraph">
<p>The <code>EventPublishingTestExecutionListener</code> introduced in Spring Framework 5.2 offers an
alternative approach to implementing a custom <code>TestExecutionListener</code>. Components in the
test&#8217;s <code>ApplicationContext</code> can listen to the following events published by the
<code>EventPublishingTestExecutionListener</code>, each of which corresponds to a method in the
<code>TestExecutionListener</code> API.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BeforeTestClassEvent</code></p>
</li>
<li>
<p><code>PrepareTestInstanceEvent</code></p>
</li>
<li>
<p><code>BeforeTestMethodEvent</code></p>
</li>
<li>
<p><code>BeforeTestExecutionEvent</code></p>
</li>
<li>
<p><code>AfterTestExecutionEvent</code></p>
</li>
<li>
<p><code>AfterTestMethodEvent</code></p>
</li>
<li>
<p><code>AfterTestClassEvent</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
These events are only published if the <code>ApplicationContext</code> has already been loaded.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These events may be consumed for various reasons, such as resetting mock beans or tracing
test execution. One advantage of consuming test execution events rather than implementing
a custom <code>TestExecutionListener</code> is that test execution events may be consumed by any
Spring bean registered in the test <code>ApplicationContext</code>, and such beans may benefit
directly from dependency injection and other features of the <code>ApplicationContext</code>. In
contrast, a <code>TestExecutionListener</code> is not a bean in the <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>In order to listen to test execution events, a Spring bean may choose to implement the
<code>org.springframework.context.ApplicationListener</code> interface. Alternatively, listener
methods can be annotated with <code>@EventListener</code> and configured to listen to one of the
particular event types listed above (see
<a href="core.html#context-functionality-events-annotation">Annotation-based Event Listeners</a>).
Due to the popularity of this approach, Spring provides the following dedicated
<code>@EventListener</code> annotations to simplify registration of test execution event listeners.
These annotations reside in the <code>org.springframework.test.context.event.annotation</code>
package.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@BeforeTestClass</code></p>
</li>
<li>
<p><code>@PrepareTestInstance</code></p>
</li>
<li>
<p><code>@BeforeTestMethod</code></p>
</li>
<li>
<p><code>@BeforeTestExecution</code></p>
</li>
<li>
<p><code>@AfterTestExecution</code></p>
</li>
<li>
<p><code>@AfterTestMethod</code></p>
</li>
<li>
<p><code>@AfterTestClass</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="testcontext-test-execution-events-exception-handling"><a class="anchor" href="#testcontext-test-execution-events-exception-handling"></a>Exception Handling</h5>
<div class="paragraph">
<p>By default, if a test execution event listener throws an exception while consuming an
event, that exception will propagate to the underlying testing framework in use (such as
JUnit or TestNG). For example, if the consumption of a <code>BeforeTestMethodEvent</code> results in
an exception, the corresponding test method will fail as a result of the exception. In
contrast, if an asynchronous test execution event listener throws an exception, the
exception will not propagate to the underlying testing framework. For further details on
asynchronous exception handling, consult the class-level javadoc for <code>@EventListener</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-test-execution-events-async"><a class="anchor" href="#testcontext-test-execution-events-async"></a>Asynchronous Listeners</h5>
<div class="paragraph">
<p>If you want a particular test execution event listener to process events asynchronously,
you can use Spring&#8217;s <a href="integration.html#scheduling-annotation-support-async">regular
<code>@Async</code> support</a>. For further details, consult the class-level javadoc for
<code>@EventListener</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-ctx-management"><a class="anchor" href="#testcontext-ctx-management"></a>3.5.5. Context Management</h4>
<div class="paragraph">
<p>Each <code>TestContext</code> provides context management and caching support for the test instance
for which it is responsible. Test instances do not automatically receive access to the
configured <code>ApplicationContext</code>. However, if a test class implements the
<code>ApplicationContextAware</code> interface, a reference to the <code>ApplicationContext</code> is supplied
to the test instance. Note that <code>AbstractJUnit4SpringContextTests</code> and
<code>AbstractTestNGSpringContextTests</code> implement <code>ApplicationContextAware</code> and, therefore,
provide access to the <code>ApplicationContext</code> automatically.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">@Autowired ApplicationContext</div>
<div class="paragraph">
<p>As an alternative to implementing the <code>ApplicationContextAware</code> interface, you can inject
the application context for your test class through the <code>@Autowired</code> annotation on either
a field or setter method, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig
class MyTest {

    @Autowired <i class="conum" data-value="1"></i><b>(1)</b>
    ApplicationContext applicationContext;

    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Injecting the <code>ApplicationContext</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig
class MyTest {

    @Autowired <i class="conum" data-value="1"></i><b>(1)</b>
    lateinit var applicationContext: ApplicationContext

    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Injecting the <code>ApplicationContext</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Similarly, if your test is configured to load a <code>WebApplicationContext</code>, you can inject
the web application context into your test, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitWebConfig <i class="conum" data-value="1"></i><b>(1)</b>
class MyWebAppTest {

    @Autowired <i class="conum" data-value="2"></i><b>(2)</b>
    WebApplicationContext wac;

    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configuring the <code>WebApplicationContext</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Injecting the <code>WebApplicationContext</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitWebConfig <i class="conum" data-value="1"></i><b>(1)</b>
class MyWebAppTest {

    @Autowired <i class="conum" data-value="2"></i><b>(2)</b>
    lateinit var wac: WebApplicationContext
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configuring the <code>WebApplicationContext</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Injecting the <code>WebApplicationContext</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Dependency injection by using <code>@Autowired</code> is provided by the
<code>DependencyInjectionTestExecutionListener</code>, which is configured by default
(see <a href="#testcontext-fixture-di">Dependency Injection of Test Fixtures</a>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Test classes that use the TestContext framework do not need to extend any particular
class or implement a specific interface to configure their application context. Instead,
configuration is achieved by declaring the <code>@ContextConfiguration</code> annotation at the
class level. If your test class does not explicitly declare application context resource
locations or component classes, the configured <code>ContextLoader</code> determines how to load a
context from a default location or default configuration classes. In addition to context
resource locations and component classes, an application context can also be configured
through application context initializers.</p>
</div>
<div class="paragraph">
<p>The following sections explain how to use Spring&#8217;s <code>@ContextConfiguration</code> annotation to
configure a test <code>ApplicationContext</code> by using XML configuration files, Groovy scripts,
component classes (typically <code>@Configuration</code> classes), or context initializers.
Alternatively, you can implement and configure your own custom <code>SmartContextLoader</code> for
advanced use cases.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#testcontext-ctx-management-xml">Context Configuration with XML resources</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-groovy">Context Configuration with Groovy Scripts</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-javaconfig">Context Configuration with Component Classes</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-mixed-config">Mixing XML, Groovy Scripts, and Component Classes</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-initializers">Context Configuration with Context Initializers</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-inheritance">Context Configuration Inheritance</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-env-profiles">Context Configuration with Environment Profiles</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-property-sources">Context Configuration with Test Property Sources</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-web">Loading a <code>WebApplicationContext</code></a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-caching">Context Caching</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-ctx-hierarchies">Context Hierarchies</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-xml"><a class="anchor" href="#testcontext-ctx-management-xml"></a>Context Configuration with XML resources</h5>
<div class="paragraph">
<p>To load an <code>ApplicationContext</code> for your tests by using XML configuration files, annotate
your test class with <code>@ContextConfiguration</code> and configure the <code>locations</code> attribute with
an array that contains the resource locations of XML configuration metadata. A plain or
relative path (for example, <code>context.xml</code>) is treated as a classpath resource that is
relative to the package in which the test class is defined. A path starting with a slash
is treated as an absolute classpath location (for example, <code>/org/example/config.xml</code>). A
path that represents a resource URL (i.e., a path prefixed with <code>classpath:</code>, <code>file:</code>,
<code>http:</code>, etc.) is used <em>as is</em>.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/app-config.xml" and
// "/test-config.xml" in the root of the classpath
@ContextConfiguration(locations={"/app-config.xml", "/test-config.xml"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Setting the locations attribute to a list of XML files.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "/app-config.xml" and
// "/test-config.xml" in the root of the classpath
@ContextConfiguration("/app-config.xml", "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Setting the locations attribute to a list of XML files.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@ContextConfiguration</code> supports an alias for the <code>locations</code> attribute through the
standard Java <code>value</code> attribute. Thus, if you do not need to declare additional
attributes in <code>@ContextConfiguration</code>, you can omit the declaration of the <code>locations</code>
attribute name and declare the resource locations by using the shorthand format
demonstrated in the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-config.xml"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying XML files without using the <code>location</code> attribute.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying XML files without using the <code>location</code> attribute.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you omit both the <code>locations</code> and the <code>value</code> attributes from the
<code>@ContextConfiguration</code> annotation, the TestContext framework tries to detect a default
XML resource location. Specifically, <code>GenericXmlContextLoader</code> and
<code>GenericXmlWebContextLoader</code> detect a default location based on the name of the test
class. If your class is named <code>com.example.MyTest</code>, <code>GenericXmlContextLoader</code> loads your
application context from <code>"classpath:com/example/MyTest-context.xml"</code>. The following
example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTest-context.xml"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Loading configuration from the default location.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTest-context.xml"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Loading configuration from the default location.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-groovy"><a class="anchor" href="#testcontext-ctx-management-groovy"></a>Context Configuration with Groovy Scripts</h5>
<div class="paragraph">
<p>To load an <code>ApplicationContext</code> for your tests by using Groovy scripts that use the
<a href="core.html#groovy-bean-definition-dsl">Groovy Bean Definition DSL</a>, you can annotate
your test class with <code>@ContextConfiguration</code> and configure the <code>locations</code> or <code>value</code>
attribute with an array that contains the resource locations of Groovy scripts. Resource
lookup semantics for Groovy scripts are the same as those described for
<a href="#testcontext-ctx-management-xml">XML configuration files</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Enabling Groovy script support</div>
Support for using Groovy scripts to load an <code>ApplicationContext</code> in the Spring
TestContext Framework is enabled automatically if Groovy is on the classpath.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to specify Groovy configuration files:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/AppConfig.groovy" and
// "/TestConfig.groovy" in the root of the classpath
@ContextConfiguration({"/AppConfig.groovy", "/TestConfig.Groovy"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "/AppConfig.groovy" and
// "/TestConfig.groovy" in the root of the classpath
@ContextConfiguration("/AppConfig.groovy", "/TestConfig.Groovy") <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying the location of Groovy configuration files.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you omit both the <code>locations</code> and <code>value</code> attributes from the <code>@ContextConfiguration</code>
annotation, the TestContext framework tries to detect a default Groovy script.
Specifically, <code>GenericGroovyXmlContextLoader</code> and <code>GenericGroovyXmlWebContextLoader</code>
detect a default location based on the name of the test class. If your class is named
<code>com.example.MyTest</code>, the Groovy context loader loads your application context from
<code>"classpath:com/example/MyTestContext.groovy"</code>. The following example shows how to use
the default:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTestContext.groovy"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Loading configuration from the default location.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTestContext.groovy"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Loading configuration from the default location.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Declaring XML configuration and Groovy scripts simultaneously</div>
<div class="paragraph">
<p>You can declare both XML configuration files and Groovy scripts simultaneously by using
the <code>locations</code> or <code>value</code> attribute of <code>@ContextConfiguration</code>. If the path to a
configured resource location ends with <code>.xml</code>, it is loaded by using an
<code>XmlBeanDefinitionReader</code>. Otherwise, it is loaded by using a
<code>GroovyBeanDefinitionReader</code>.</p>
</div>
<div class="paragraph">
<p>The following listing shows how to combine both in an integration test:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "/app-config.xml" and "/TestConfig.groovy"
@ContextConfiguration({ "/app-config.xml", "/TestConfig.groovy" })
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from
// "/app-config.xml" and "/TestConfig.groovy"
@ContextConfiguration("/app-config.xml", "/TestConfig.groovy")
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-javaconfig"><a class="anchor" href="#testcontext-ctx-management-javaconfig"></a>Context Configuration with Component Classes</h5>
<div class="paragraph">
<p>To load an <code>ApplicationContext</code> for your tests by using component classes (see
<a href="core.html#beans-java">Java-based container configuration</a>), you can annotate your test
class with <code>@ContextConfiguration</code> and configure the <code>classes</code> attribute with an array
that contains references to component classes. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from AppConfig and TestConfig
@ContextConfiguration(classes = {AppConfig.class, TestConfig.class}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying component classes.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from AppConfig and TestConfig
@ContextConfiguration(classes = [AppConfig::class, TestConfig::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying component classes.</td>
</tr>
</table>
</div>
<div id="testcontext-ctx-management-javaconfig-component-classes" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Component Classes</div>
<div class="paragraph">
<p>The term &#8220;component class&#8221; can refer to any of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A class annotated with <code>@Configuration</code>.</p>
</li>
<li>
<p>A component (that is, a class annotated with <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, or other stereotype annotations).</p>
</li>
<li>
<p>A JSR-330 compliant class that is annotated with <code>javax.inject</code> annotations.</p>
</li>
<li>
<p>Any class that contains <code>@Bean</code>-methods.</p>
</li>
<li>
<p>Any other class that is intended to be registered as a Spring component (i.e., a Spring
bean in the <code>ApplicationContext</code>), potentially taking advantage of automatic autowiring
of a single constructor without the use of Spring annotations.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the javadoc of
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a> and
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a> for further information
regarding the configuration and semantics of component classes, paying special attention
to the discussion of <code>@Bean</code> Lite Mode.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you omit the <code>classes</code> attribute from the <code>@ContextConfiguration</code> annotation, the
TestContext framework tries to detect the presence of default configuration classes.
Specifically, <code>AnnotationConfigContextLoader</code> and <code>AnnotationConfigWebContextLoader</code>
detect all <code>static</code> nested classes of the test class that meet the requirements for
configuration class implementations, as specified in the
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a> javadoc.
Note that the name of the configuration class is arbitrary. In addition, a test class can
contain more than one <code>static</code> nested configuration class if desired. In the following
example, the <code>OrderServiceTest</code> class declares a <code>static</code> nested configuration class
named <code>Config</code> that is automatically used to load the <code>ApplicationContext</code> for the test
class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig <i class="conum" data-value="1"></i><b>(1)</b>
// ApplicationContext will be loaded from the
// static nested Config class
class OrderServiceTest {

    @Configuration
    static class Config {

        // this bean will be injected into the OrderServiceTest class
        @Bean
        OrderService orderService() {
            OrderService orderService = new OrderServiceImpl();
            // set properties, etc.
            return orderService;
        }
    }

    @Autowired
    OrderService orderService;

    @Test
    void testOrderService() {
        // test the orderService
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Loading configuration information from the nested <code>Config</code> class.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig <i class="conum" data-value="1"></i><b>(1)</b>
// ApplicationContext will be loaded from the nested Config class
class OrderServiceTest {

    @Autowired
    lateinit var orderService: OrderService

    @Configuration
    class Config {

        // this bean will be injected into the OrderServiceTest class
        @Bean
        fun orderService(): OrderService {
            // set properties, etc.
            return OrderServiceImpl()
        }
    }

    @Test
    fun testOrderService() {
        // test the orderService
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Loading configuration information from the nested <code>Config</code> class.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-mixed-config"><a class="anchor" href="#testcontext-ctx-management-mixed-config"></a>Mixing XML, Groovy Scripts, and Component Classes</h5>
<div class="paragraph">
<p>It may sometimes be desirable to mix XML configuration files, Groovy scripts, and
component classes (typically <code>@Configuration</code> classes) to configure an
<code>ApplicationContext</code> for your tests. For example, if you use XML configuration in
production, you may decide that you want to use <code>@Configuration</code> classes to configure
specific Spring-managed components for your tests, or vice versa.</p>
</div>
<div class="paragraph">
<p>Furthermore, some third-party frameworks (such as Spring Boot) provide first-class
support for loading an <code>ApplicationContext</code> from different types of resources
simultaneously (for example, XML configuration files, Groovy scripts, and
<code>@Configuration</code> classes). The Spring Framework, historically, has not supported this for
standard deployments. Consequently, most of the <code>SmartContextLoader</code> implementations that
the Spring Framework delivers in the <code>spring-test</code> module support only one resource type
for each test context. However, this does not mean that you cannot use both. One
exception to the general rule is that the <code>GenericGroovyXmlContextLoader</code> and
<code>GenericGroovyXmlWebContextLoader</code> support both XML configuration files and Groovy
scripts simultaneously. Furthermore, third-party frameworks may choose to support the
declaration of both <code>locations</code> and <code>classes</code> through <code>@ContextConfiguration</code>, and, with
the standard testing support in the TestContext framework, you have the following options.</p>
</div>
<div class="paragraph">
<p>If you want to use resource locations (for example, XML or Groovy) and <code>@Configuration</code>
classes to configure your tests, you must pick one as the entry point, and that one must
include or import the other. For example, in XML or Groovy scripts, you can include
<code>@Configuration</code> classes by using component scanning or defining them as normal Spring
beans, whereas, in a <code>@Configuration</code> class, you can use <code>@ImportResource</code> to import XML
configuration files or Groovy scripts. Note that this behavior is semantically equivalent
to how you configure your application in production: In production configuration, you
define either a set of XML or Groovy resource locations or a set of <code>@Configuration</code>
classes from which your production <code>ApplicationContext</code> is loaded, but you still have the
freedom to include or import the other type of configuration.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-initializers"><a class="anchor" href="#testcontext-ctx-management-initializers"></a>Context Configuration with Context Initializers</h5>
<div class="paragraph">
<p>To configure an <code>ApplicationContext</code> for your tests by using context initializers,
annotate your test class with <code>@ContextConfiguration</code> and configure the <code>initializers</code>
attribute with an array that contains references to classes that implement
<code>ApplicationContextInitializer</code>. The declared context initializers are then used to
initialize the <code>ConfigurableApplicationContext</code> that is loaded for your tests. Note that
the concrete <code>ConfigurableApplicationContext</code> type supported by each declared initializer
must be compatible with the type of <code>ApplicationContext</code> created by the
<code>SmartContextLoader</code> in use (typically a <code>GenericApplicationContext</code>). Furthermore, the
order in which the initializers are invoked depends on whether they implement Spring&#8217;s
<code>Ordered</code> interface or are annotated with Spring&#8217;s <code>@Order</code> annotation or the standard
<code>@Priority</code> annotation. The following example shows how to use initializers:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from TestConfig
// and initialized by TestAppCtxInitializer
@ContextConfiguration(
    classes = TestConfig.class,
    initializers = TestAppCtxInitializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying configuration by using a configuration class and an initializer.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from TestConfig
// and initialized by TestAppCtxInitializer
@ContextConfiguration(
        classes = [TestConfig::class],
        initializers = [TestAppCtxInitializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying configuration by using a configuration class and an initializer.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also omit the declaration of XML configuration files, Groovy scripts, or
component classes in <code>@ContextConfiguration</code> entirely and instead declare only
<code>ApplicationContextInitializer</code> classes, which are then responsible for registering beans
in the context&#8201;&#8212;&#8201;for example, by programmatically loading bean definitions from XML
files or configuration classes. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be initialized by EntireAppInitializer
// which presumably registers beans in the context
@ContextConfiguration(initializers = EntireAppInitializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying configuration by using only an initializer.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be initialized by EntireAppInitializer
// which presumably registers beans in the context
@ContextConfiguration(initializers = [EntireAppInitializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying configuration by using only an initializer.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-inheritance"><a class="anchor" href="#testcontext-ctx-management-inheritance"></a>Context Configuration Inheritance</h5>
<div class="paragraph">
<p><code>@ContextConfiguration</code> supports boolean <code>inheritLocations</code> and <code>inheritInitializers</code>
attributes that denote whether resource locations or component classes and context
initializers declared by superclasses should be inherited. The default value for both
flags is <code>true</code>. This means that a test class inherits the resource locations or
component classes as well as the context initializers declared by any superclasses.
Specifically, the resource locations or component classes for a test class are appended
to the list of resource locations or annotated classes declared by superclasses.
Similarly, the initializers for a given test class are added to the set of initializers
defined by test superclasses. Thus, subclasses have the option of extending the resource
locations, component classes, or context initializers.</p>
</div>
<div class="paragraph">
<p>If the <code>inheritLocations</code> or <code>inheritInitializers</code> attribute in <code>@ContextConfiguration</code>
is set to <code>false</code>, the resource locations or component classes and the context
initializers, respectively, for the test class shadow and effectively replace the
configuration defined by superclasses.</p>
</div>
<div class="paragraph">
<p>In the next example, which uses XML resource locations, the <code>ApplicationContext</code> for
<code>ExtendedTest</code> is loaded from <code>base-config.xml</code> and <code>extended-config.xml</code>, in that order.
Beans defined in <code>extended-config.xml</code> can, therefore, override (that is, replace) those
defined in <code>base-config.xml</code>. The following example shows how one class can extend
another and use both its own configuration file and the superclass&#8217;s configuration file:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/base-config.xml"
// in the root of the classpath
@ContextConfiguration("/base-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from "/base-config.xml" and
// "/extended-config.xml" in the root of the classpath
@ContextConfiguration("/extended-config.xml") <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest extends BaseTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configuration file defined in the superclass.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Configuration file defined in the subclass.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "/base-config.xml"
// in the root of the classpath
@ContextConfiguration("/base-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
open class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from "/base-config.xml" and
// "/extended-config.xml" in the root of the classpath
@ContextConfiguration("/extended-config.xml") <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest : BaseTest() {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configuration file defined in the superclass.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Configuration file defined in the subclass.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Similarly, in the next example, which uses component classes, the <code>ApplicationContext</code>
for <code>ExtendedTest</code> is loaded from the <code>BaseConfig</code> and <code>ExtendedConfig</code> classes, in that
order. Beans defined in <code>ExtendedConfig</code> can, therefore, override (that is, replace)
those defined in <code>BaseConfig</code>. The following example shows how one class can extend
another and use both its own configuration class and the superclass&#8217;s configuration class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// ApplicationContext will be loaded from BaseConfig
@SpringJUnitConfig(BaseConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from BaseConfig and ExtendedConfig
@SpringJUnitConfig(ExtendedConfig.class) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest extends BaseTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configuration class defined in the superclass.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Configuration class defined in the subclass.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// ApplicationContext will be loaded from BaseConfig
@SpringJUnitConfig(BaseConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
open class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from BaseConfig and ExtendedConfig
@SpringJUnitConfig(ExtendedConfig::class) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest : BaseTest() {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configuration class defined in the superclass.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Configuration class defined in the subclass.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the next example, which uses context initializers, the <code>ApplicationContext</code> for
<code>ExtendedTest</code> is initialized by using <code>BaseInitializer</code> and <code>ExtendedInitializer</code>. Note,
however, that the order in which the initializers are invoked depends on whether they
implement Spring&#8217;s <code>Ordered</code> interface or are annotated with Spring&#8217;s <code>@Order</code> annotation
or the standard <code>@Priority</code> annotation. The following example shows how one class can
extend another and use both its own initializer and the superclass&#8217;s initializer:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// ApplicationContext will be initialized by BaseInitializer
@SpringJUnitConfig(initializers = BaseInitializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class BaseTest {
    // class body...
}

// ApplicationContext will be initialized by BaseInitializer
// and ExtendedInitializer
@SpringJUnitConfig(initializers = ExtendedInitializer.class) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest extends BaseTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Initializer defined in the superclass.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Initializer defined in the subclass.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// ApplicationContext will be initialized by BaseInitializer
@SpringJUnitConfig(initializers = [BaseInitializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
open class BaseTest {
    // class body...
}

// ApplicationContext will be initialized by BaseInitializer
// and ExtendedInitializer
@SpringJUnitConfig(initializers = [ExtendedInitializer::class]) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest : BaseTest() {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Initializer defined in the superclass.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Initializer defined in the subclass.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-env-profiles"><a class="anchor" href="#testcontext-ctx-management-env-profiles"></a>Context Configuration with Environment Profiles</h5>
<div class="paragraph">
<p>The Spring Framework has first-class support for the notion of environments and profiles
(AKA "bean definition profiles"), and integration tests can be configured to activate
particular bean definition profiles for various testing scenarios. This is achieved by
annotating a test class with the <code>@ActiveProfiles</code> annotation and supplying a list of
profiles that should be activated when loading the <code>ApplicationContext</code> for the test.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can use <code>@ActiveProfiles</code> with any implementation of the <code>SmartContextLoader</code>
SPI, but <code>@ActiveProfiles</code> is not supported with implementations of the older
<code>ContextLoader</code> SPI.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consider two examples with XML configuration and <code>@Configuration</code> classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- app-config.xml --&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="..."&gt;

    &lt;bean id="transferService"
            class="com.bank.service.internal.DefaultTransferService"&gt;
        &lt;constructor-arg ref="accountRepository"/&gt;
        &lt;constructor-arg ref="feePolicy"/&gt;
    &lt;/bean&gt;

    &lt;bean id="accountRepository"
            class="com.bank.repository.internal.JdbcAccountRepository"&gt;
        &lt;constructor-arg ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="feePolicy"
        class="com.bank.service.internal.ZeroFeePolicy"/&gt;

    &lt;beans profile="dev"&gt;
        &lt;jdbc:embedded-database id="dataSource"&gt;
            &lt;jdbc:script
                location="classpath:com/bank/config/sql/schema.sql"/&gt;
            &lt;jdbc:script
                location="classpath:com/bank/config/sql/test-data.sql"/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

    &lt;beans profile="production"&gt;
        &lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/&gt;
    &lt;/beans&gt;

    &lt;beans profile="default"&gt;
        &lt;jdbc:embedded-database id="dataSource"&gt;
            &lt;jdbc:script
                location="classpath:com/bank/config/sql/schema.sql"/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "classpath:/app-config.xml"
@ContextConfiguration("/app-config.xml")
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "classpath:/app-config.xml"
@ContextConfiguration("/app-config.xml")
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    lateinit var transferService: TransferService

    @Test
    fun testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When <code>TransferServiceTest</code> is run, its <code>ApplicationContext</code> is loaded from the
<code>app-config.xml</code> configuration file in the root of the classpath. If you inspect
<code>app-config.xml</code>, you can see that the <code>accountRepository</code> bean has a dependency on a
<code>dataSource</code> bean. However, <code>dataSource</code> is not defined as a top-level bean. Instead,
<code>dataSource</code> is defined three times: in the <code>production</code> profile, in the <code>dev</code> profile,
and in the <code>default</code> profile.</p>
</div>
<div class="paragraph">
<p>By annotating <code>TransferServiceTest</code> with <code>@ActiveProfiles("dev")</code>, we instruct the Spring
TestContext Framework to load the <code>ApplicationContext</code> with the active profiles set to
<code>{"dev"}</code>. As a result, an embedded database is created and populated with test data, and
the <code>accountRepository</code> bean is wired with a reference to the development <code>DataSource</code>.
That is likely what we want in an integration test.</p>
</div>
<div class="paragraph">
<p>It is sometimes useful to assign beans to a <code>default</code> profile. Beans within the default
profile are included only when no other profile is specifically activated. You can use
this to define &#8220;fallback&#8221; beans to be used in the application&#8217;s default state. For
example, you may explicitly provide a data source for <code>dev</code> and <code>production</code> profiles,
but define an in-memory data source as a default when neither of these is active.</p>
</div>
<div class="paragraph">
<p>The following code listings demonstrate how to implement the same configuration and
integration test with <code>@Configuration</code> classes instead of XML:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@Profile("dev")
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@Profile("dev")
class StandaloneDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .addScript("classpath:com/bank/config/sql/test-data.sql")
                .build()
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@Profile("production")
public class JndiDataConfig {

    @Bean(destroyMethod="")
    public DataSource dataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@Profile("production")
class JndiDataConfig {

    @Bean(destroyMethod = "")
    fun dataSource(): DataSource {
        val ctx = InitialContext()
        return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@Profile("default")
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
@Profile("default")
class DefaultDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .build()
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class TransferServiceConfig {

    @Autowired DataSource dataSource;

    @Bean
    public TransferService transferService() {
        return new DefaultTransferService(accountRepository(), feePolicy());
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public FeePolicy feePolicy() {
        return new ZeroFeePolicy();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Configuration
class TransferServiceConfig {

    @Autowired
    lateinit var dataSource: DataSource

    @Bean
    fun transferService(): TransferService {
        return DefaultTransferService(accountRepository(), feePolicy())
    }

    @Bean
    fun accountRepository(): AccountRepository {
        return JdbcAccountRepository(dataSource)
    }

    @Bean
    fun feePolicy(): FeePolicy {
        return ZeroFeePolicy()
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(
        TransferServiceConfig::class,
        StandaloneDataConfig::class,
        JndiDataConfig::class,
        DefaultDataConfig::class)
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    lateinit var transferService: TransferService

    @Test
    fun testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this variation, we have split the XML configuration into four independent
<code>@Configuration</code> classes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TransferServiceConfig</code>: Acquires a <code>dataSource</code> through dependency injection by using
<code>@Autowired</code>.</p>
</li>
<li>
<p><code>StandaloneDataConfig</code>: Defines a <code>dataSource</code> for an embedded database suitable for
developer tests.</p>
</li>
<li>
<p><code>JndiDataConfig</code>: Defines a <code>dataSource</code> that is retrieved from JNDI in a production
environment.</p>
</li>
<li>
<p><code>DefaultDataConfig</code>: Defines a <code>dataSource</code> for a default embedded database, in case no
profile is active.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As with the XML-based configuration example, we still annotate <code>TransferServiceTest</code> with
<code>@ActiveProfiles("dev")</code>, but this time we specify all four configuration classes by
using the <code>@ContextConfiguration</code> annotation. The body of the test class itself remains
completely unchanged.</p>
</div>
<div class="paragraph">
<p>It is often the case that a single set of profiles is used across multiple test classes
within a given project. Thus, to avoid duplicate declarations of the <code>@ActiveProfiles</code>
annotation, you can declare <code>@ActiveProfiles</code> once on a base class, and subclasses
automatically inherit the <code>@ActiveProfiles</code> configuration from the base class. In the
following example, the declaration of <code>@ActiveProfiles</code> (as well as other annotations)
has been moved to an abstract superclass, <code>AbstractIntegrationTest</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles("dev")
abstract class AbstractIntegrationTest {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(
        TransferServiceConfig::class,
        StandaloneDataConfig::class,
        JndiDataConfig::class,
        DefaultDataConfig::class)
@ActiveProfiles("dev")
abstract class AbstractIntegrationTest {
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// "dev" profile inherited from superclass
class TransferServiceTest extends AbstractIntegrationTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// "dev" profile inherited from superclass
class TransferServiceTest : AbstractIntegrationTest() {

    @Autowired
    lateinit var transferService: TransferService

    @Test
    fun testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@ActiveProfiles</code> also supports an <code>inheritProfiles</code> attribute that can be used to
disable the inheritance of active profiles, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// "dev" profile overridden with "production"
@ActiveProfiles(profiles = "production", inheritProfiles = false)
class ProductionTransferServiceTest extends AbstractIntegrationTest {
    // test body
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// "dev" profile overridden with "production"
@ActiveProfiles("production", inheritProfiles = false)
class ProductionTransferServiceTest : AbstractIntegrationTest() {
    // test body
}</code></pre>
</div>
</div>
<div id="testcontext-ctx-management-env-profiles-ActiveProfilesResolver" class="paragraph">
<p>Furthermore, it is sometimes necessary to resolve active profiles for tests
programmatically instead of declaratively&#8201;&#8212;&#8201;for example, based on:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The current operating system.</p>
</li>
<li>
<p>Whether tests are being executed on a continuous integration build server.</p>
</li>
<li>
<p>The presence of certain environment variables.</p>
</li>
<li>
<p>The presence of custom class-level annotations.</p>
</li>
<li>
<p>Other concerns.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To resolve active bean definition profiles programmatically, you can implement
a custom <code>ActiveProfilesResolver</code> and register it by using the <code>resolver</code>
attribute of <code>@ActiveProfiles</code>. For further information, see the corresponding
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/ActiveProfilesResolver.html">javadoc</a>.
The following example demonstrates how to implement and register a custom
<code>OperatingSystemActiveProfilesResolver</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// "dev" profile overridden programmatically via a custom resolver
@ActiveProfiles(
        resolver = OperatingSystemActiveProfilesResolver.class,
        inheritProfiles = false)
class TransferServiceTest extends AbstractIntegrationTest {
    // test body
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// "dev" profile overridden programmatically via a custom resolver
@ActiveProfiles(
        resolver = OperatingSystemActiveProfilesResolver::class,
        inheritProfiles = false)
class TransferServiceTest : AbstractIntegrationTest() {
    // test body
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class OperatingSystemActiveProfilesResolver implements ActiveProfilesResolver {

    @Override
    public String[] resolve(Class&lt;?&gt; testClass) {
        String profile = ...;
        // determine the value of profile based on the operating system
        return new String[] {profile};
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class OperatingSystemActiveProfilesResolver : ActiveProfilesResolver {

    override fun resolve(testClass: Class&lt;*&gt;): Array&lt;String&gt; {
        val profile: String = ...
        // determine the value of profile based on the operating system
        return arrayOf(profile)
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-property-sources"><a class="anchor" href="#testcontext-ctx-management-property-sources"></a>Context Configuration with Test Property Sources</h5>
<div class="paragraph">
<p>The Spring Framework has first-class support for the notion of an environment with a
hierarchy of property sources, and you can configure integration tests with test-specific
property sources. In contrast to the <code>@PropertySource</code> annotation used on
<code>@Configuration</code> classes, you can declare the <code>@TestPropertySource</code> annotation on a test
class to declare resource locations for test properties files or inlined properties.
These test property sources are added to the set of <code>PropertySources</code> in the
<code>Environment</code> for the <code>ApplicationContext</code> loaded for the annotated integration test.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can use <code>@TestPropertySource</code> with any implementation of the <code>SmartContextLoader</code>
SPI, but <code>@TestPropertySource</code> is not supported with implementations of the older
<code>ContextLoader</code> SPI.</p>
</div>
<div class="paragraph">
<p>Implementations of <code>SmartContextLoader</code> gain access to merged test property source values
through the <code>getPropertySourceLocations()</code> and <code>getPropertySourceProperties()</code> methods in
<code>MergedContextConfiguration</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="declaring-test-property-sources"><a class="anchor" href="#declaring-test-property-sources"></a>Declaring Test Property Sources</h6>
<div class="paragraph">
<p>You can configure test properties files by using the <code>locations</code> or <code>value</code> attribute of
<code>@TestPropertySource</code>.</p>
</div>
<div class="paragraph">
<p>Both traditional and XML-based properties file formats are supported&#8201;&#8212;&#8201;for example,
<code>"classpath:/com/example/test.properties"</code> or <code>"file:///path/to/file.xml"</code>.</p>
</div>
<div class="paragraph">
<p>Each path is interpreted as a Spring <code>Resource</code>. A plain path (for example,
<code>"test.properties"</code>) is treated as a classpath resource that is relative to the package
in which the test class is defined. A path starting with a slash is treated as an
absolute classpath resource (for example: <code>"/org/example/test.xml"</code>). A path that
references a URL (for example, a path prefixed with <code>classpath:</code>, <code>file:</code>, or <code>http:</code>) is
loaded by using the specified resource protocol. Resource location wildcards (such as
<code><strong>*/</strong>.properties</code>) are not permitted: Each location must evaluate to exactly one
<code>.properties</code> or <code>.xml</code> resource.</p>
</div>
<div class="paragraph">
<p>The following example uses a test properties file:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying a properties file with an absolute path.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifying a properties file with an absolute path.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can configure inlined properties in the form of key-value pairs by using the
<code>properties</code> attribute of <code>@TestPropertySource</code>, as shown in the next example. All
key-value pairs are added to the enclosing <code>Environment</code> as a single test
<code>PropertySource</code> with the highest precedence.</p>
</div>
<div class="paragraph">
<p>The supported syntax for key-value pairs is the same as the syntax defined for entries in
a Java properties file:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>key=value</code></p>
</li>
<li>
<p><code>key:value</code></p>
</li>
<li>
<p><code>key value</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example sets two inlined properties:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration
@TestPropertySource(properties = {"timezone = GMT", "port: 4242"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Setting two properties by using two variations of the key-value syntax.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration
@TestPropertySource(properties = ["timezone = GMT", "port: 4242"]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Setting two properties by using two variations of the key-value syntax.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of Spring Framework 5.2, <code>@TestPropertySource</code> can be used as <em>repeatable annotation</em>.
That means that you can have multiple declarations of <code>@TestPropertySource</code> on a single
test class, with the <code>locations</code> and <code>properties</code> from later <code>@TestPropertySource</code>
annotations overriding those from previous <code>@TestPropertySource</code> annotations.</p>
</div>
<div class="paragraph">
<p>In addition, you may declare multiple composed annotations on a test class that are each
meta-annotated with <code>@TestPropertySource</code>, and all of those <code>@TestPropertySource</code>
declarations will contribute to your test property sources.</p>
</div>
<div class="paragraph">
<p>Directly present <code>@TestPropertySource</code> annotations always take precedence over
meta-present <code>@TestPropertySource</code> annotations. In other words, <code>locations</code> and
<code>properties</code> from a directly present <code>@TestPropertySource</code> annotation will override the
<code>locations</code> and <code>properties</code> from a <code>@TestPropertySource</code> annotation used as a
meta-annotation.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="default-properties-file-detection"><a class="anchor" href="#default-properties-file-detection"></a>Default Properties File Detection</h6>
<div class="paragraph">
<p>If <code>@TestPropertySource</code> is declared as an empty annotation (that is, without explicit
values for the <code>locations</code> or <code>properties</code> attributes), an attempt is made to detect a
default properties file relative to the class that declared the annotation. For example,
if the annotated test class is <code>com.example.MyTest</code>, the corresponding default properties
file is <code>classpath:com/example/MyTest.properties</code>. If the default cannot be detected, an
<code>IllegalStateException</code> is thrown.</p>
</div>
</div>
<div class="sect5">
<h6 id="precedence"><a class="anchor" href="#precedence"></a>Precedence</h6>
<div class="paragraph">
<p>Test property sources have higher precedence than those loaded from the operating
system&#8217;s environment, Java system properties, or property sources added by the
application declaratively by using <code>@PropertySource</code> or programmatically. Thus, test
property sources can be used to selectively override properties defined in system and
application property sources. Furthermore, inlined properties have higher precedence than
properties loaded from resource locations.</p>
</div>
<div class="paragraph">
<p>In the next example, the <code>timezone</code> and <code>port</code> properties and any properties defined in
<code>"/test.properties"</code> override any properties of the same name that are defined in system
and application property sources. Furthermore, if the <code>"/test.properties"</code> file defines
entries for the <code>timezone</code> and <code>port</code> properties those are overridden by the inlined
properties declared by using the <code>properties</code> attribute. The following example shows how
to specify properties both in a file and inline:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration
@TestPropertySource(
    locations = "/test.properties",
    properties = {"timezone = GMT", "port: 4242"}
)
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration
@TestPropertySource("/test.properties",
        properties = ["timezone = GMT", "port: 4242"]
)
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="inheriting-and-overriding-test-property-sources"><a class="anchor" href="#inheriting-and-overriding-test-property-sources"></a>Inheriting and Overriding Test Property Sources</h6>
<div class="paragraph">
<p><code>@TestPropertySource</code> supports boolean <code>inheritLocations</code> and <code>inheritProperties</code>
attributes that denote whether resource locations for properties files and inlined
properties declared by superclasses should be inherited. The default value for both flags
is <code>true</code>. This means that a test class inherits the locations and inlined properties
declared by any superclasses. Specifically, the locations and inlined properties for a
test class are appended to the locations and inlined properties declared by superclasses.
Thus, subclasses have the option of extending the locations and inlined properties. Note
that properties that appear later shadow (that is, override) properties of the same name
that appear earlier. In addition, the aforementioned precedence rules apply for inherited
test property sources as well.</p>
</div>
<div class="paragraph">
<p>If the <code>inheritLocations</code> or <code>inheritProperties</code> attribute in <code>@TestPropertySource</code> is
set to <code>false</code>, the locations or inlined properties, respectively, for the test class
shadow and effectively replace the configuration defined by superclasses.</p>
</div>
<div class="paragraph">
<p>In the next example, the <code>ApplicationContext</code> for <code>BaseTest</code> is loaded by using only the
<code>base.properties</code> file as a test property source. In contrast, the <code>ApplicationContext</code>
for <code>ExtendedTest</code> is loaded by using the <code>base.properties</code> and <code>extended.properties</code>
files as test property source locations. The following example shows how to define
properties in both a subclass and its superclass by using <code>properties</code> files:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TestPropertySource("base.properties")
@ContextConfiguration
class BaseTest {
    // ...
}

@TestPropertySource("extended.properties")
@ContextConfiguration
class ExtendedTest extends BaseTest {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@TestPropertySource("base.properties")
@ContextConfiguration
open class BaseTest {
    // ...
}

@TestPropertySource("extended.properties")
@ContextConfiguration
class ExtendedTest : BaseTest() {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the next example, the <code>ApplicationContext</code> for <code>BaseTest</code> is loaded by using only the
inlined <code>key1</code> property. In contrast, the <code>ApplicationContext</code> for <code>ExtendedTest</code> is
loaded by using the inlined <code>key1</code> and <code>key2</code> properties. The following example shows how
to define properties in both a subclass and its superclass by using inline properties:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TestPropertySource(properties = "key1 = value1")
@ContextConfiguration
class BaseTest {
    // ...
}

@TestPropertySource(properties = "key2 = value2")
@ContextConfiguration
class ExtendedTest extends BaseTest {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@TestPropertySource(properties = ["key1 = value1"])
@ContextConfiguration
open class BaseTest {
    // ...
}

@TestPropertySource(properties = ["key2 = value2"])
@ContextConfiguration
class ExtendedTest : BaseTest() {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-dynamic-property-sources"><a class="anchor" href="#testcontext-ctx-management-dynamic-property-sources"></a>Context Configuration with Dynamic Property Sources</h5>
<div class="paragraph">
<p>As of Spring Framework 5.2.5, the TestContext framework provides support for <em>dynamic</em>
property sources via the <code>@DynamicPropertySource</code> annotation. This annotation can be used
in integration tests that need to add properties with dynamic values to the set of
<code>PropertySources</code> in the <code>Environment</code> for the <code>ApplicationContext</code> loaded for the
integration test.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>@DynamicPropertySource</code> annotation and its supporting infrastructure were
originally designed to allow properties from
<a href="https://www.testcontainers.org/">Testcontainers</a> based tests to be exposed easily to
Spring integration tests. However, this feature may also be used with any form of
external resource whose lifecycle is maintained outside the test&#8217;s <code>ApplicationContext</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In contrast to the <a href="#testcontext-ctx-management-property-sources"><code>@TestPropertySource</code></a>
annotation that is applied at the class level, <code>@DynamicPropertySource</code> must be applied
to a <code>static</code> method that accepts a single <code>DynamicPropertyRegistry</code> argument which is
used to add <em>name-value</em> pairs to the <code>Environment</code>. Values are dynamic and provided via
a <code>Supplier</code> which is only invoked when the property is resolved. Typically, method
references are used to supply values, as can be seen in the following example which uses
the Testcontainers project to manage a Redis container outside of the Spring
<code>ApplicationContext</code>. The IP address and port of the managed Redis container are made
available to components within the test&#8217;s <code>ApplicationContext</code> via the <code>redis.host</code> and
<code>redis.port</code> properties. These properties can be injected into Spring-managed components
via <code>@Value("${redis.host}")</code> and <code>@Value("${redis.port}")</code>, respectively.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig(/* ... */)
@Testcontainers
class ExampleIntegrationTests {

    @Container
    static RedisContainer redis = new RedisContainer();

    @DynamicPropertySource
    static void redisProperties(DynamicPropertyRegistry registry) {
        registry.add("redis.host", redis::getContainerIpAddress);
        registry.add("redis.port", redis::getMappedPort);
    }

    // tests ...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(/* ... */)
@Testcontainers
class ExampleIntegrationTests {

    companion object {

        @Container
        @JvmStatic
        val redis: RedisContainer = RedisContainer()

        @DynamicPropertySource
        @JvmStatic
        fun redisProperties(registry: DynamicPropertyRegistry) {
            registry.add("redis.host", redis::getContainerIpAddress)
            registry.add("redis.port", redis::getMappedPort)
        }
    }

    // tests ...

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-web"><a class="anchor" href="#testcontext-ctx-management-web"></a>Loading a <code>WebApplicationContext</code></h5>
<div class="paragraph">
<p>To instruct the TestContext framework to load a <code>WebApplicationContext</code> instead of a
standard <code>ApplicationContext</code>, you can annotate the respective test class with
<code>@WebAppConfiguration</code>.</p>
</div>
<div class="paragraph">
<p>The presence of <code>@WebAppConfiguration</code> on your test class instructs the TestContext
framework (TCF) that a <code>WebApplicationContext</code> (WAC) should be loaded for your
integration tests. In the background, the TCF makes sure that a <code>MockServletContext</code> is
created and supplied to your test&#8217;s WAC. By default, the base resource path for your
<code>MockServletContext</code> is set to <code>src/main/webapp</code>. This is interpreted as a path relative
to the root of your JVM (normally the path to your project). If you are familiar with the
directory structure of a web application in a Maven project, you know that
<code>src/main/webapp</code> is the default location for the root of your WAR. If you need to
override this default, you can provide an alternate path to the <code>@WebAppConfiguration</code>
annotation (for example, <code>@WebAppConfiguration("src/test/webapp")</code>). If you wish to
reference a base resource path from the classpath instead of the file system, you can use
Spring&#8217;s <code>classpath:</code> prefix.</p>
</div>
<div class="paragraph">
<p>Note that Spring&#8217;s testing support for <code>WebApplicationContext</code> implementations is on par
with its support for standard <code>ApplicationContext</code> implementations. When testing with a
<code>WebApplicationContext</code>, you are free to declare XML configuration files, Groovy scripts,
or <code>@Configuration</code> classes by using <code>@ContextConfiguration</code>. You are also free to use
any other test annotations, such as <code>@ActiveProfiles</code>, <code>@TestExecutionListeners</code>, <code>@Sql</code>,
<code>@Rollback</code>, and others.</p>
</div>
<div class="paragraph">
<p>The remaining examples in this section show some of the various configuration options for
loading a <code>WebApplicationContext</code>. The following example shows the TestContext
framework&#8217;s support for convention over configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)

// defaults to "file:src/main/webapp"
@WebAppConfiguration

// detects "WacTests-context.xml" in the same package
// or static nested @Configuration classes
@ContextConfiguration
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)

// defaults to "file:src/main/webapp"
@WebAppConfiguration

// detects "WacTests-context.xml" in the same package
// or static nested @Configuration classes
@ContextConfiguration
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you annotate a test class with <code>@WebAppConfiguration</code> without specifying a resource
base path, the resource path effectively defaults to <code>file:src/main/webapp</code>. Similarly,
if you declare <code>@ContextConfiguration</code> without specifying resource <code>locations</code>, component
<code>classes</code>, or context <code>initializers</code>, Spring tries to detect the presence of your
configuration by using conventions (that is, <code>WacTests-context.xml</code> in the same package
as the <code>WacTests</code> class or static nested <code>@Configuration</code> classes).</p>
</div>
<div class="paragraph">
<p>The following example shows how to explicitly declare a resource base path with
<code>@WebAppConfiguration</code> and an XML resource location with <code>@ContextConfiguration</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)

// file system resource
@WebAppConfiguration("webapp")

// classpath resource
@ContextConfiguration("/spring/test-servlet-config.xml")
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)

// file system resource
@WebAppConfiguration("webapp")

// classpath resource
@ContextConfiguration("/spring/test-servlet-config.xml")
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The important thing to note here is the different semantics for paths with these two
annotations. By default, <code>@WebAppConfiguration</code> resource paths are file system based,
whereas <code>@ContextConfiguration</code> resource locations are classpath based.</p>
</div>
<div class="paragraph">
<p>The following example shows that we can override the default resource semantics for both
annotations by specifying a Spring resource prefix:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)

// classpath resource
@WebAppConfiguration("classpath:test-web-resources")

// file system resource
@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)

// classpath resource
@WebAppConfiguration("classpath:test-web-resources")

// file system resource
@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Contrast the comments in this example with the previous example.</p>
</div>
<div class="openblock">
<div class="title"><a id="testcontext-ctx-management-web-mocks"></a>Working with Web Mocks</div>
<div class="content">
<div class="paragraph">
<p>To provide comprehensive web testing support, the TestContext framework has a
<code>ServletTestExecutionListener</code> that is enabled by default. When testing against a
<code>WebApplicationContext</code>, this <a href="#testcontext-key-abstractions"><code>TestExecutionListener</code></a>
sets up default thread-local state by using Spring Web&#8217;s <code>RequestContextHolder</code> before
each test method and creates a <code>MockHttpServletRequest</code>, a <code>MockHttpServletResponse</code>, and
a <code>ServletWebRequest</code> based on the base resource path configured with
<code>@WebAppConfiguration</code>. <code>ServletTestExecutionListener</code> also ensures that the
<code>MockHttpServletResponse</code> and <code>ServletWebRequest</code> can be injected into the test instance,
and, once the test is complete, it cleans up thread-local state.</p>
</div>
<div class="paragraph">
<p>Once you have a <code>WebApplicationContext</code> loaded for your test, you might find that you
need to interact with the web mocks&#8201;&#8212;&#8201;for example, to set up your test fixture or to
perform assertions after invoking your web component. The following example shows which
mocks can be autowired into your test instance. Note that the <code>WebApplicationContext</code> and
<code>MockServletContext</code> are both cached across the test suite, whereas the other mocks are
managed per test method by the <code>ServletTestExecutionListener</code>.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitWebConfig
class WacTests {

    @Autowired
    WebApplicationContext wac; // cached

    @Autowired
    MockServletContext servletContext; // cached

    @Autowired
    MockHttpSession session;

    @Autowired
    MockHttpServletRequest request;

    @Autowired
    MockHttpServletResponse response;

    @Autowired
    ServletWebRequest webRequest;

    //...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitWebConfig
class WacTests {

    @Autowired
    lateinit var wac: WebApplicationContext // cached

    @Autowired
    lateinit var servletContext: MockServletContext // cached

    @Autowired
    lateinit var session: MockHttpSession

    @Autowired
    lateinit var request: MockHttpServletRequest

    @Autowired
    lateinit var response: MockHttpServletResponse

    @Autowired
    lateinit var webRequest: ServletWebRequest

    //...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-caching"><a class="anchor" href="#testcontext-ctx-management-caching"></a>Context Caching</h5>
<div class="paragraph">
<p>Once the TestContext framework loads an <code>ApplicationContext</code> (or <code>WebApplicationContext</code>)
for a test, that context is cached and reused for all subsequent tests that declare the
same unique context configuration within the same test suite. To understand how caching
works, it is important to understand what is meant by &#8220;unique&#8221; and &#8220;test suite.&#8221;</p>
</div>
<div class="paragraph">
<p>An <code>ApplicationContext</code> can be uniquely identified by the combination of configuration
parameters that is used to load it. Consequently, the unique combination of configuration
parameters is used to generate a key under which the context is cached. The TestContext
framework uses the following configuration parameters to build the context cache key:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>locations</code> (from <code>@ContextConfiguration</code>)</p>
</li>
<li>
<p><code>classes</code> (from <code>@ContextConfiguration</code>)</p>
</li>
<li>
<p><code>contextInitializerClasses</code> (from <code>@ContextConfiguration</code>)</p>
</li>
<li>
<p><code>contextCustomizers</code> (from <code>ContextCustomizerFactory</code>)</p>
</li>
<li>
<p><code>contextLoader</code> (from <code>@ContextConfiguration</code>)</p>
</li>
<li>
<p><code>parent</code> (from <code>@ContextHierarchy</code>)</p>
</li>
<li>
<p><code>activeProfiles</code> (from <code>@ActiveProfiles</code>)</p>
</li>
<li>
<p><code>propertySourceLocations</code> (from <code>@TestPropertySource</code>)</p>
</li>
<li>
<p><code>propertySourceProperties</code> (from <code>@TestPropertySource</code>)</p>
</li>
<li>
<p><code>resourceBasePath</code> (from <code>@WebAppConfiguration</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, if <code>TestClassA</code> specifies <code>{"app-config.xml", "test-config.xml"}</code> for the
<code>locations</code> (or <code>value</code>) attribute of <code>@ContextConfiguration</code>, the TestContext framework
loads the corresponding <code>ApplicationContext</code> and stores it in a <code>static</code> context cache
under a key that is based solely on those locations. So, if <code>TestClassB</code> also defines
<code>{"app-config.xml", "test-config.xml"}</code> for its locations (either explicitly or
implicitly through inheritance) but does not define <code>@WebAppConfiguration</code>, a different
<code>ContextLoader</code>, different active profiles, different context initializers, different
test property sources, or a different parent context, then the same <code>ApplicationContext</code>
is shared by both test classes. This means that the setup cost for loading an application
context is incurred only once (per test suite), and subsequent test execution is much
faster.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Test suites and forked processes</div>
<div class="paragraph">
<p>The Spring TestContext framework stores application contexts in a static cache. This
means that the context is literally stored in a <code>static</code> variable. In other words, if
tests execute in separate processes, the static cache is cleared between each test
execution, which effectively disables the caching mechanism.</p>
</div>
<div class="paragraph">
<p>To benefit from the caching mechanism, all tests must run within the same process or test
suite. This can be achieved by executing all tests as a group within an IDE. Similarly,
when executing tests with a build framework such as Ant, Maven, or Gradle, it is
important to make sure that the build framework does not fork between tests. For example,
if the
<a href="https://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html#forkMode"><code>forkMode</code></a>
for the Maven Surefire plug-in is set to <code>always</code> or <code>pertest</code>, the TestContext framework
cannot cache application contexts between test classes, and the build process runs
significantly more slowly as a result.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The size of the context cache is bounded with a default maximum size of 32. Whenever the
maximum size is reached, a least recently used (LRU) eviction policy is used to evict and
close stale contexts. You can configure the maximum size from the command line or a build
script by setting a JVM system property named <code>spring.test.context.cache.maxSize</code>. As an
alternative, you can set the same property programmatically by using the
<code>SpringProperties</code> API.</p>
</div>
<div class="paragraph">
<p>Since having a large number of application contexts loaded within a given test suite can
cause the suite to take an unnecessarily long time to execute, it is often beneficial to
know exactly how many contexts have been loaded and cached. To view the statistics for
the underlying context cache, you can set the log level for the
<code>org.springframework.test.context.cache</code> logging category to <code>DEBUG</code>.</p>
</div>
<div class="paragraph">
<p>In the unlikely case that a test corrupts the application context and requires reloading
(for example, by modifying a bean definition or the state of an application object), you
can annotate your test class or test method with <code>@DirtiesContext</code> (see the discussion of
<code>@DirtiesContext</code> in <a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a>). This instructs Spring
to remove the context from the cache and rebuild the application context before running
the next test that requires the same application context. Note that support for the
<code>@DirtiesContext</code> annotation is provided by the
<code>DirtiesContextBeforeModesTestExecutionListener</code> and the
<code>DirtiesContextTestExecutionListener</code>, which are enabled by default.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-ctx-hierarchies"><a class="anchor" href="#testcontext-ctx-management-ctx-hierarchies"></a>Context Hierarchies</h5>
<div class="paragraph">
<p>When writing integration tests that rely on a loaded Spring <code>ApplicationContext</code>, it is
often sufficient to test against a single context. However, there are times when it is
beneficial or even necessary to test against a hierarchy of <code>ApplicationContext</code>
instances. For example, if you are developing a Spring MVC web application, you typically
have a root <code>WebApplicationContext</code> loaded by Spring&#8217;s <code>ContextLoaderListener</code> and a
child <code>WebApplicationContext</code> loaded by Spring&#8217;s <code>DispatcherServlet</code>. This results in a
parent-child context hierarchy where shared components and infrastructure configuration
are declared in the root context and consumed in the child context by web-specific
components. Another use case can be found in Spring Batch applications, where you often
have a parent context that provides configuration for shared batch infrastructure and a
child context for the configuration of a specific batch job.</p>
</div>
<div class="paragraph">
<p>You can write integration tests that use context hierarchies by declaring context
configuration with the <code>@ContextHierarchy</code> annotation, either on an individual test class
or within a test class hierarchy. If a context hierarchy is declared on multiple classes
within a test class hierarchy, you can also merge or override the context configuration
for a specific, named level in the context hierarchy. When merging configuration for a
given level in the hierarchy, the configuration resource type (that is, XML configuration
files or component classes) must be consistent. Otherwise, it is perfectly acceptable to
have different levels in a context hierarchy configured using different resource types.</p>
</div>
<div class="paragraph">
<p>The remaining JUnit Jupiter based examples in this section show common configuration
scenarios for integration tests that require the use of context hierarchies.</p>
</div>
<div class="openblock">
<div class="title">Single test class with context hierarchy</div>
<div class="content">
<div class="paragraph">
<p><code>ControllerIntegrationTests</code> represents a typical integration testing scenario for a
Spring MVC web application by declaring a context hierarchy that consists of two levels,
one for the root <code>WebApplicationContext</code> (loaded by using the <code>TestAppConfig</code>
<code>@Configuration</code> class) and one for the dispatcher servlet <code>WebApplicationContext</code>
(loaded by using the <code>WebConfig</code> <code>@Configuration</code> class). The <code>WebApplicationContext</code>
that is autowired into the test instance is the one for the child context (that is, the
lowest context in the hierarchy). The following listing shows this configuration scenario:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = TestAppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class ControllerIntegrationTests {

    @Autowired
    WebApplicationContext wac;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
@WebAppConfiguration
@ContextHierarchy(
    ContextConfiguration(classes = [TestAppConfig::class]),
    ContextConfiguration(classes = [WebConfig::class]))
class ControllerIntegrationTests {

    @Autowired
    lateinit var wac: WebApplicationContext

    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title">Class hierarchy with implicit parent context</div>
<div class="content">
<div class="paragraph">
<p>The test classes in this example define a context hierarchy within a test class
hierarchy. <code>AbstractWebTests</code> declares the configuration for a root
<code>WebApplicationContext</code> in a Spring-powered web application. Note, however, that
<code>AbstractWebTests</code> does not declare <code>@ContextHierarchy</code>. Consequently, subclasses of
<code>AbstractWebTests</code> can optionally participate in a context hierarchy or follow the
standard semantics for <code>@ContextConfiguration</code>. <code>SoapWebServiceTests</code> and
<code>RestWebServiceTests</code> both extend <code>AbstractWebTests</code> and define a context hierarchy by
using <code>@ContextHierarchy</code>. The result is that three application contexts are loaded (one
for each declaration of <code>@ContextConfiguration</code>), and the application context loaded
based on the configuration in <code>AbstractWebTests</code> is set as the parent context for each of
the contexts loaded for the concrete subclasses. The following listing shows this
configuration scenario:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
@WebAppConfiguration
@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
public abstract class AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration("/spring/soap-ws-config.xml"))
public class SoapWebServiceTests extends AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration("/spring/rest-ws-config.xml"))
public class RestWebServiceTests extends AbstractWebTests {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
@WebAppConfiguration
@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
abstract class AbstractWebTests

@ContextHierarchy(ContextConfiguration("/spring/soap-ws-config.xml"))
class SoapWebServiceTests : AbstractWebTests()

@ContextHierarchy(ContextConfiguration("/spring/rest-ws-config.xml"))
class RestWebServiceTests : AbstractWebTests()</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title">Class hierarchy with merged context hierarchy configuration</div>
<div class="content">
<div class="paragraph">
<p>The classes in this example show the use of named hierarchy levels in order to merge the
configuration for specific levels in a context hierarchy. <code>BaseTests</code> defines two levels
in the hierarchy, <code>parent</code> and <code>child</code>. <code>ExtendedTests</code> extends <code>BaseTests</code> and instructs
the Spring TestContext Framework to merge the context configuration for the <code>child</code>
hierarchy level, by ensuring that the names declared in the <code>name</code> attribute in
<code>@ContextConfiguration</code> are both <code>child</code>. The result is that three application contexts
are loaded: one for <code>/app-config.xml</code>, one for <code>/user-config.xml</code>, and one for
<code>{"/user-config.xml", "/order-config.xml"}</code>. As with the previous example, the
application context loaded from <code>/app-config.xml</code> is set as the parent context for the
contexts loaded from <code>/user-config.xml</code> and <code>{"/user-config.xml", "/order-config.xml"}</code>.
The following listing shows this configuration scenario:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
@ContextHierarchy({
    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
    @ContextConfiguration(name = "child", locations = "/user-config.xml")
})
class BaseTests {}

@ContextHierarchy(
    @ContextConfiguration(name = "child", locations = "/order-config.xml")
)
class ExtendedTests extends BaseTests {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
@ContextHierarchy(
    ContextConfiguration(name = "parent", locations = ["/app-config.xml"]),
    ContextConfiguration(name = "child", locations = ["/user-config.xml"]))
open class BaseTests {}

@ContextHierarchy(
    ContextConfiguration(name = "child", locations = ["/order-config.xml"])
)
class ExtendedTests : BaseTests() {}</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title">Class hierarchy with overridden context hierarchy configuration</div>
<div class="content">
<div class="paragraph">
<p>In contrast to the previous example, this example demonstrates how to override the
configuration for a given named level in a context hierarchy by setting the
<code>inheritLocations</code> flag in <code>@ContextConfiguration</code> to <code>false</code>. Consequently, the
application context for <code>ExtendedTests</code> is loaded only from <code>/test-user-config.xml</code> and
has its parent set to the context loaded from <code>/app-config.xml</code>. The following listing
shows this configuration scenario:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
@ContextHierarchy({
    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
    @ContextConfiguration(name = "child", locations = "/user-config.xml")
})
class BaseTests {}

@ContextHierarchy(
    @ContextConfiguration(
        name = "child",
        locations = "/test-user-config.xml",
        inheritLocations = false
))
class ExtendedTests extends BaseTests {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
@ContextHierarchy(
    ContextConfiguration(name = "parent", locations = ["/app-config.xml"]),
    ContextConfiguration(name = "child", locations = ["/user-config.xml"]))
open class BaseTests {}

@ContextHierarchy(
        ContextConfiguration(
                name = "child",
                locations = ["/test-user-config.xml"],
                inheritLocations = false
        ))
class ExtendedTests : BaseTests() {}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Dirtying a context within a context hierarchy</div>
If you use <code>@DirtiesContext</code> in a test whose context is configured as part of a
context hierarchy, you can use the <code>hierarchyMode</code> flag to control how the context cache
is cleared. For further details, see the discussion of <code>@DirtiesContext</code> in
<a href="#spring-testing-annotation-dirtiescontext">Spring Testing Annotations</a> and the
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/annotation/DirtiesContext.html"><code>@DirtiesContext</code></a> javadoc.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-fixture-di"><a class="anchor" href="#testcontext-fixture-di"></a>3.5.6. Dependency Injection of Test Fixtures</h4>
<div class="paragraph">
<p>When you use the <code>DependencyInjectionTestExecutionListener</code> (which is configured by
default), the dependencies of your test instances are injected from beans in the
application context that you configured with <code>@ContextConfiguration</code> or related
annotations. You may use setter injection, field injection, or both, depending on
which annotations you choose and whether you place them on setter methods or fields.
If you are using JUnit Jupiter you may also optionally use constructor injection
(see <a href="#testcontext-junit-jupiter-di">Dependency Injection with <code>SpringExtension</code></a>). For consistency with Spring&#8217;s annotation-based
injection support, you may also use Spring&#8217;s <code>@Autowired</code> annotation or the <code>@Inject</code>
annotation from JSR-330 for field and setter injection.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For testing frameworks other than JUnit Jupiter, the TestContext framework does not
participate in instantiation of the test class. Thus, the use of <code>@Autowired</code> or
<code>@Inject</code> for constructors has no effect for test classes.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although field injection is discouraged in production code, field injection is
actually quite natural in test code. The rationale for the difference is that you will
never instantiate your test class directly. Consequently, there is no need to be able to
invoke a <code>public</code> constructor or setter method on your test class.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Because <code>@Autowired</code> is used to perform <a href="core.html#beans-factory-autowire">autowiring by
type</a>, if you have multiple bean definitions of the same type, you cannot rely on this
approach for those particular beans. In that case, you can use <code>@Autowired</code> in
conjunction with <code>@Qualifier</code>. You can also choose to use <code>@Inject</code> in conjunction with
<code>@Named</code>. Alternatively, if your test class has access to its <code>ApplicationContext</code>, you
can perform an explicit lookup by using (for example) a call to
<code>applicationContext.getBean("titleRepository", TitleRepository.class)</code>.</p>
</div>
<div class="paragraph">
<p>If you do not want dependency injection applied to your test instances, do not annotate
fields or setter methods with <code>@Autowired</code> or <code>@Inject</code>. Alternatively, you can disable
dependency injection altogether by explicitly configuring your class with
<code>@TestExecutionListeners</code> and omitting <code>DependencyInjectionTestExecutionListener.class</code>
from the list of listeners.</p>
</div>
<div class="paragraph">
<p>Consider the scenario of testing a <code>HibernateTitleRepository</code> class, as outlined in the
<a href="#integration-testing-goals">Goals</a> section. The next two code listings demonstrate the
use of <code>@Autowired</code> on fields and setter methods. The application context configuration
is presented after all sample code listings.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The dependency injection behavior in the following code listings is not specific to JUnit
Jupiter. The same DI techniques can be used in conjunction with any supported testing
framework.</p>
</div>
<div class="paragraph">
<p>The following examples make calls to static assertion methods, such as <code>assertNotNull()</code>,
but without prepending the call with <code>Assertions</code>. In such cases, assume that the method
was properly imported through an <code>import static</code> declaration that is not shown in the
example.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The first code listing shows a JUnit Jupiter based implementation of the test class that
uses <code>@Autowired</code> for field injection:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    @Autowired
    HibernateTitleRepository titleRepository;

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    @Autowired
    lateinit var titleRepository: HibernateTitleRepository

    @Test
    fun findById() {
        val title = titleRepository.findById(10)
        assertNotNull(title)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can configure the class to use <code>@Autowired</code> for setter injection, as
follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    HibernateTitleRepository titleRepository;

    @Autowired
    void setTitleRepository(HibernateTitleRepository titleRepository) {
        this.titleRepository = titleRepository;
    }

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    lateinit var titleRepository: HibernateTitleRepository

    @Autowired
    fun setTitleRepository(titleRepository: HibernateTitleRepository) {
        this.titleRepository = titleRepository
    }

    @Test
    fun findById() {
        val title = titleRepository.findById(10)
        assertNotNull(title)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding code listings use the same XML context file referenced by the
<code>@ContextConfiguration</code> annotation (that is, <code>repository-config.xml</code>). The following
shows this configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;!-- this bean will be injected into the HibernateTitleRepositoryTests class --&gt;
    &lt;bean id="titleRepository" class="com.foo.repository.hibernate.HibernateTitleRepository"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;

    &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt;
        &lt;!-- configuration elided for brevity --&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are extending from a Spring-provided test base class that happens to use
<code>@Autowired</code> on one of its setter methods, you might have multiple beans of the affected
type defined in your application context (for example, multiple <code>DataSource</code> beans). In
such a case, you can override the setter method and use the <code>@Qualifier</code> annotation to
indicate a specific target bean, as follows (but make sure to delegate to the overridden
method in the superclass as well):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// ...

    @Autowired
    @Override
    public void setDataSource(@Qualifier("myDataSource") DataSource dataSource) {
        super.setDataSource(dataSource);
    }

// ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// ...

    @Autowired
    override fun setDataSource(@Qualifier("myDataSource") dataSource: DataSource) {
        super.setDataSource(dataSource)
    }

// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The specified qualifier value indicates the specific <code>DataSource</code> bean to inject,
narrowing the set of type matches to a specific bean. Its value is matched against
<code>&lt;qualifier&gt;</code> declarations within the corresponding <code>&lt;bean&gt;</code> definitions. The bean name
is used as a fallback qualifier value, so you can effectively also point to a specific
bean by name there (as shown earlier, assuming that <code>myDataSource</code> is the bean <code>id</code>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-web-scoped-beans"><a class="anchor" href="#testcontext-web-scoped-beans"></a>3.5.7. Testing Request- and Session-scoped Beans</h4>
<div class="paragraph">
<p>Spring has supported <a href="core.html#beans-factory-scopes-other">Request- and session-scoped
beans</a> since the early years, and you can test your request-scoped and session-scoped
beans by following these steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensure that a <code>WebApplicationContext</code> is loaded for your test by annotating your test
class with <code>@WebAppConfiguration</code>.</p>
</li>
<li>
<p>Inject the mock request or session into your test instance and prepare your test
fixture as appropriate.</p>
</li>
<li>
<p>Invoke your web component that you retrieved from the configured
<code>WebApplicationContext</code> (with dependency injection).</p>
</li>
<li>
<p>Perform assertions against the mocks.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The next code snippet shows the XML configuration for a login use case. Note that the
<code>userService</code> bean has a dependency on a request-scoped <code>loginAction</code> bean. Also, the
<code>LoginAction</code> is instantiated by using <a href="core.html#expressions">SpEL expressions</a> that
retrieve the username and password from the current HTTP request. In our test, we want to
configure these request parameters through the mock managed by the TestContext framework.
The following listing shows the configuration for this use case:</p>
</div>
<div class="listingblock">
<div class="title">Request-scoped bean configuration</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans&gt;

    &lt;bean id="userService" class="com.example.SimpleUserService"
            c:loginAction-ref="loginAction"/&gt;

    &lt;bean id="loginAction" class="com.example.LoginAction"
            c:username="#{request.getParameter('user')}"
            c:password="#{request.getParameter('pswd')}"
            scope="request"&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <code>RequestScopedBeanTests</code>, we inject both the <code>UserService</code> (that is, the subject under
test) and the <code>MockHttpServletRequest</code> into our test instance. Within our
<code>requestScope()</code> test method, we set up our test fixture by setting request parameters in
the provided <code>MockHttpServletRequest</code>. When the <code>loginUser()</code> method is invoked on our
<code>userService</code>, we are assured that the user service has access to the request-scoped
<code>loginAction</code> for the current <code>MockHttpServletRequest</code> (that is, the one in which we just
set parameters). We can then perform assertions against the results based on the known
inputs for the username and password. The following listing shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitWebConfig
class RequestScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpServletRequest request;

    @Test
    void requestScope() {
        request.setParameter("user", "enigma");
        request.setParameter("pswd", "$pr!ng");

        LoginResults results = userService.loginUser();
        // assert results
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitWebConfig
class RequestScopedBeanTests {

    @Autowired lateinit var userService: UserService
    @Autowired lateinit var request: MockHttpServletRequest

    @Test
    fun requestScope() {
        request.setParameter("user", "enigma")
        request.setParameter("pswd", "\$pr!ng")

        val results = userService.loginUser()
        // assert results
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following code snippet is similar to the one we saw earlier for a request-scoped
bean. However, this time, the <code>userService</code> bean has a dependency on a session-scoped
<code>userPreferences</code> bean. Note that the <code>UserPreferences</code> bean is instantiated by using a
SpEL expression that retrieves the theme from the current HTTP session. In our test, we
need to configure a theme in the mock session managed by the TestContext framework. The
following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="title">Session-scoped bean configuration</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans&gt;

    &lt;bean id="userService" class="com.example.SimpleUserService"
            c:userPreferences-ref="userPreferences" /&gt;

    &lt;bean id="userPreferences" class="com.example.UserPreferences"
            c:theme="#{session.getAttribute('theme')}"
            scope="session"&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <code>SessionScopedBeanTests</code>, we inject the <code>UserService</code> and the <code>MockHttpSession</code> into
our test instance. Within our <code>sessionScope()</code> test method, we set up our test fixture by
setting the expected <code>theme</code> attribute in the provided <code>MockHttpSession</code>. When the
<code>processUserPreferences()</code> method is invoked on our <code>userService</code>, we are assured that
the user service has access to the session-scoped <code>userPreferences</code> for the current
<code>MockHttpSession</code>, and we can perform assertions against the results based on the
configured theme. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitWebConfig
class SessionScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpSession session;

    @Test
    void sessionScope() throws Exception {
        session.setAttribute("theme", "blue");

        Results results = userService.processUserPreferences();
        // assert results
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitWebConfig
class SessionScopedBeanTests {

    @Autowired lateinit var userService: UserService
    @Autowired lateinit var session: MockHttpSession

    @Test
    fun sessionScope() {
        session.setAttribute("theme", "blue")

        val results = userService.processUserPreferences()
        // assert results
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-tx"><a class="anchor" href="#testcontext-tx"></a>3.5.8. Transaction Management</h4>
<div class="paragraph">
<p>In the TestContext framework, transactions are managed by the
<code>TransactionalTestExecutionListener</code>, which is configured by default, even if you do not
explicitly declare <code>@TestExecutionListeners</code> on your test class. To enable support for
transactions, however, you must configure a <code>PlatformTransactionManager</code> bean in the
<code>ApplicationContext</code> that is loaded with <code>@ContextConfiguration</code> semantics (further
details are provided later). In addition, you must declare Spring&#8217;s <code>@Transactional</code>
annotation either at the class or the method level for your tests.</p>
</div>
<div class="sect4">
<h5 id="testcontext-tx-test-managed-transactions"><a class="anchor" href="#testcontext-tx-test-managed-transactions"></a>Test-managed Transactions</h5>
<div class="paragraph">
<p>Test-managed transactions are transactions that are managed declaratively by using the
<code>TransactionalTestExecutionListener</code> or programmatically by using <code>TestTransaction</code>
(described later). You should not confuse such transactions with Spring-managed
transactions (those managed directly by Spring within the <code>ApplicationContext</code> loaded for
tests) or application-managed transactions (those managed programmatically within
application code that is invoked by tests). Spring-managed and application-managed
transactions typically participate in test-managed transactions. However, you should use
caution if Spring-managed or application-managed transactions are configured with any
propagation type other than <code>REQUIRED</code> or <code>SUPPORTS</code> (see the discussion on
<a href="data-access.html#tx-propagation">transaction propagation</a> for details).</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">Preemptive timeouts and test-managed transactions</div>
<div class="paragraph">
<p>Caution must be taken when using any form of preemptive timeouts from a testing framework
in conjunction with Spring&#8217;s test-managed transactions.</p>
</div>
<div class="paragraph">
<p>Specifically, Spring’s testing support binds transaction state to the current thread (via
a <code>java.lang.ThreadLocal</code> variable) <em>before</em> the current test method is invoked. If a
testing framework invokes the current test method in a new thread in order to support a
preemptive timeout, any actions performed within the current test method will <em>not</em> be
invoked within the test-managed transaction. Consequently, the result of any such actions
will not be rolled back with the test-managed transaction. On the contrary, such actions
will be committed to the persistent store&#8201;&#8212;&#8201;for example, a relational database&#8201;&#8212;&#8201;even
though the test-managed transaction is properly rolled back by Spring.</p>
</div>
<div class="paragraph">
<p>Situations in which this can occur include but are not limited to the following.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JUnit 4&#8217;s <code>@Test(timeout = &#8230;&#8203;)</code> support and <code>TimeOut</code> rule</p>
</li>
<li>
<p>JUnit Jupiter&#8217;s <code>assertTimeoutPreemptively(&#8230;&#8203;)</code> methods in the
<code>org.junit.jupiter.api.Assertions</code> class</p>
</li>
<li>
<p>TestNG&#8217;s <code>@Test(timeOut = &#8230;&#8203;)</code> support</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-enabling-transactions"><a class="anchor" href="#testcontext-tx-enabling-transactions"></a>Enabling and Disabling Transactions</h5>
<div class="paragraph">
<p>Annotating a test method with <code>@Transactional</code> causes the test to be run within a
transaction that is, by default, automatically rolled back after completion of the test.
If a test class is annotated with <code>@Transactional</code>, each test method within that class
hierarchy runs within a transaction. Test methods that are not annotated with
<code>@Transactional</code> (at the class or method level) are not run within a transaction. Note
that <code>@Transactional</code> is not supported on test lifecycle methods — for example, methods
annotated with JUnit Jupiter&#8217;s <code>@BeforeAll</code>, <code>@BeforeEach</code>, etc. Furthermore, tests that
are annotated with <code>@Transactional</code> but have the <code>propagation</code> attribute set to
<code>NOT_SUPPORTED</code> are not run within a transaction.</p>
</div>
<table id="testcontext-tx-attribute-support" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. <code>@Transactional</code> attribute support</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Supported for test-managed transactions</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>value</code> and <code>transactionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>propagation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">only <code>Propagation.NOT_SUPPORTED</code> is supported</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isolation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>readOnly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rollbackFor</code> and <code>rollbackForClassName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no: use <code>TestTransaction.flagForRollback()</code> instead</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noRollbackFor</code> and <code>noRollbackForClassName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no: use <code>TestTransaction.flagForCommit()</code> instead</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Method-level lifecycle methods — for example, methods annotated with JUnit Jupiter&#8217;s
<code>@BeforeEach</code> or <code>@AfterEach</code> — are run within a test-managed transaction. On the other
hand, suite-level and class-level lifecycle methods — for example, methods annotated with
JUnit Jupiter&#8217;s <code>@BeforeAll</code> or <code>@AfterAll</code> and methods annotated with TestNG&#8217;s
<code>@BeforeSuite</code>, <code>@AfterSuite</code>, <code>@BeforeClass</code>, or <code>@AfterClass</code> — are <em>not</em> run within a
test-managed transaction.</p>
</div>
<div class="paragraph">
<p>If you need to execute code in a suite-level or class-level lifecycle method within a
transaction, you may wish to inject a corresponding <code>PlatformTransactionManager</code> into
your test class and then use that with a <code>TransactionTemplate</code> for programmatic
transaction management.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that <a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a> and
<a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>
are preconfigured for transactional support at the class level.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates a common scenario for writing an integration test for
a Hibernate-based <code>UserRepository</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig(TestConfig.class)
@Transactional
class HibernateUserRepositoryTests {

    @Autowired
    HibernateUserRepository repository;

    @Autowired
    SessionFactory sessionFactory;

    JdbcTemplate jdbcTemplate;

    @Autowired
    void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    void createUser() {
        // track initial state in test database:
        final int count = countRowsInTable("user");

        User user = new User(...);
        repository.save(user);

        // Manual flush is required to avoid false positive in test
        sessionFactory.getCurrentSession().flush();
        assertNumUsers(count + 1);
    }

    private int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    private void assertNumUsers(int expected) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
@Transactional
class HibernateUserRepositoryTests {

    @Autowired
    lateinit var repository: HibernateUserRepository

    @Autowired
    lateinit var sessionFactory: SessionFactory

    lateinit var jdbcTemplate: JdbcTemplate

    @Autowired
    fun setDataSource(dataSource: DataSource) {
        this.jdbcTemplate = JdbcTemplate(dataSource)
    }

    @Test
    fun createUser() {
        // track initial state in test database:
        val count = countRowsInTable("user")

        val user = User()
        repository.save(user)

        // Manual flush is required to avoid false positive in test
        sessionFactory.getCurrentSession().flush()
        assertNumUsers(count + 1)
    }

    private fun countRowsInTable(tableName: String): Int {
        return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName)
    }

    private fun assertNumUsers(expected: Int) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As explained in <a href="#testcontext-tx-rollback-and-commit-behavior">Transaction Rollback and Commit Behavior</a>, there is no need to
clean up the database after the <code>createUser()</code> method runs, since any changes made to the
database are automatically rolled back by the <code>TransactionalTestExecutionListener</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-rollback-and-commit-behavior"><a class="anchor" href="#testcontext-tx-rollback-and-commit-behavior"></a>Transaction Rollback and Commit Behavior</h5>
<div class="paragraph">
<p>By default, test transactions will be automatically rolled back after completion of the
test; however, transactional commit and rollback behavior can be configured declaratively
via the <code>@Commit</code> and <code>@Rollback</code> annotations. See the corresponding entries in the
<a href="#integration-testing-annotations">annotation support</a> section for further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-programmatic-tx-mgt"><a class="anchor" href="#testcontext-tx-programmatic-tx-mgt"></a>Programmatic Transaction Management</h5>
<div class="paragraph">
<p>You can interact with test-managed transactions programmatically by using the static
methods in <code>TestTransaction</code>. For example, you can use <code>TestTransaction</code> within test
methods, before methods, and after methods to start or end the current test-managed
transaction or to configure the current test-managed transaction for rollback or commit.
Support for <code>TestTransaction</code> is automatically available whenever the
<code>TransactionalTestExecutionListener</code> is enabled.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates some of the features of <code>TestTransaction</code>. See the
javadoc for <a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestTransaction.html"><code>TestTransaction</code></a>
for further details.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration(classes = TestConfig.class)
public class ProgrammaticTransactionManagementTests extends
        AbstractTransactionalJUnit4SpringContextTests {

    @Test
    public void transactionalTest() {
        // assert initial state in test database:
        assertNumUsers(2);

        deleteFromTables("user");

        // changes to the database will be committed!
        TestTransaction.flagForCommit();
        TestTransaction.end();
        assertFalse(TestTransaction.isActive());
        assertNumUsers(0);

        TestTransaction.start();
        // perform other actions against the database that will
        // be automatically rolled back after the test completes...
    }

    protected void assertNumUsers(int expected) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ContextConfiguration(classes = [TestConfig::class])
class ProgrammaticTransactionManagementTests : AbstractTransactionalJUnit4SpringContextTests() {

    @Test
    fun transactionalTest() {
        // assert initial state in test database:
        assertNumUsers(2)

        deleteFromTables("user")

        // changes to the database will be committed!
        TestTransaction.flagForCommit()
        TestTransaction.end()
        assertFalse(TestTransaction.isActive())
        assertNumUsers(0)

        TestTransaction.start()
        // perform other actions against the database that will
        // be automatically rolled back after the test completes...
    }

    protected fun assertNumUsers(expected: Int) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"))
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-before-and-after-tx"><a class="anchor" href="#testcontext-tx-before-and-after-tx"></a>Running Code Outside of a Transaction</h5>
<div class="paragraph">
<p>Occasionally, you may need to execute certain code before or after a transactional test
method but outside the transactional context&#8201;&#8212;&#8201;for example, to verify the initial
database state prior to running your test or to verify expected transactional commit
behavior after your test runs (if the test was configured to commit the transaction).
<code>TransactionalTestExecutionListener</code> supports the <code>@BeforeTransaction</code> and
<code>@AfterTransaction</code> annotations for exactly such scenarios. You can annotate any <code>void</code>
method in a test class or any <code>void</code> default method in a test interface with one of these
annotations, and the <code>TransactionalTestExecutionListener</code> ensures that your before
transaction method or after transaction method runs at the appropriate time.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Any before methods (such as methods annotated with JUnit Jupiter&#8217;s <code>@BeforeEach</code>)
and any after methods (such as methods annotated with JUnit Jupiter&#8217;s <code>@AfterEach</code>) are
run within a transaction. In addition, methods annotated with <code>@BeforeTransaction</code> or
<code>@AfterTransaction</code> are not run for test methods that are not configured to run within a
transaction.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-mgr-config"><a class="anchor" href="#testcontext-tx-mgr-config"></a>Configuring a Transaction Manager</h5>
<div class="paragraph">
<p><code>TransactionalTestExecutionListener</code> expects a <code>PlatformTransactionManager</code> bean to be
defined in the Spring <code>ApplicationContext</code> for the test. If there are multiple instances
of <code>PlatformTransactionManager</code> within the test&#8217;s <code>ApplicationContext</code>, you can declare a
qualifier by using <code>@Transactional("myTxMgr")</code> or <code>@Transactional(transactionManager =
"myTxMgr")</code>, or <code>TransactionManagementConfigurer</code> can be implemented by an
<code>@Configuration</code> class. Consult the
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestContextTransactionUtils.html#retrieveTransactionManager-org.springframework.test.context.TestContext-java.lang.String-">javadoc
for <code>TestContextTransactionUtils.retrieveTransactionManager()</code></a> for details on the
algorithm used to look up a transaction manager in the test&#8217;s <code>ApplicationContext</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-annotation-demo"><a class="anchor" href="#testcontext-tx-annotation-demo"></a>Demonstration of All Transaction-related Annotations</h5>
<div class="paragraph">
<p>The following JUnit Jupiter based example displays a fictitious integration testing
scenario that highlights all transaction-related annotations. The example is not intended
to demonstrate best practices but rather to demonstrate how these annotations can be
used. See the <a href="#integration-testing-annotations">annotation support</a> section for further
information and configuration examples. <a href="#testcontext-executing-sql-declaratively-tx">Transaction management for <code>@Sql</code></a> contains an additional example that uses <code>@Sql</code> for
declarative SQL script execution with default transaction rollback semantics. The
following example shows the relevant annotations:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig
@Transactional(transactionManager = "txMgr")
@Commit
class FictitiousTransactionalTest {

    @BeforeTransaction
    void verifyInitialDatabaseState() {
        // logic to verify the initial state before a transaction is started
    }

    @BeforeEach
    void setUpTestDataWithinTransaction() {
        // set up test data within the transaction
    }

    @Test
    // overrides the class-level @Commit setting
    @Rollback
    void modifyDatabaseWithinTransaction() {
        // logic which uses the test data and modifies database state
    }

    @AfterEach
    void tearDownWithinTransaction() {
        // execute "tear down" logic within the transaction
    }

    @AfterTransaction
    void verifyFinalDatabaseState() {
        // logic to verify the final state after transaction has rolled back
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig
@Transactional(transactionManager = "txMgr")
@Commit
class FictitiousTransactionalTest {

    @BeforeTransaction
    fun verifyInitialDatabaseState() {
        // logic to verify the initial state before a transaction is started
    }

    @BeforeEach
    fun setUpTestDataWithinTransaction() {
        // set up test data within the transaction
    }

    @Test
    // overrides the class-level @Commit setting
    @Rollback
    fun modifyDatabaseWithinTransaction() {
        // logic which uses the test data and modifies database state
    }

    @AfterEach
    fun tearDownWithinTransaction() {
        // execute "tear down" logic within the transaction
    }

    @AfterTransaction
    fun verifyFinalDatabaseState() {
        // logic to verify the final state after transaction has rolled back
    }

}</code></pre>
</div>
</div>
<div id="testcontext-tx-false-positives" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Avoid false positives when testing ORM code</div>
<div class="paragraph">
<p>When you test application code that manipulates the state of a Hibernate session or JPA
persistence context, make sure to flush the underlying unit of work within test methods
that run that code. Failing to flush the underlying unit of work can produce false
positives: Your test passes, but the same code throws an exception in a live, production
environment. Note that this applies to any ORM framework that maintains an in-memory unit
of work. In the following Hibernate-based example test case, one method demonstrates a
false positive, and the other method correctly exposes the results of flushing the
session:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// ...

@Autowired
SessionFactory sessionFactory;

@Transactional
@Test // no expected exception!
public void falsePositive() {
    updateEntityInHibernateSession();
    // False positive: an exception will be thrown once the Hibernate
    // Session is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithSessionFlush() {
    updateEntityInHibernateSession();
    // Manual flush is required to avoid false positive in test
    sessionFactory.getCurrentSession().flush();
}

// ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// ...

@Autowired
lateinit var sessionFactory: SessionFactory

@Transactional
@Test // no expected exception!
fun falsePositive() {
    updateEntityInHibernateSession()
    // False positive: an exception will be thrown once the Hibernate
    // Session is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
fun updateWithSessionFlush() {
    updateEntityInHibernateSession()
    // Manual flush is required to avoid false positive in test
    sessionFactory.getCurrentSession().flush()
}

// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows matching methods for JPA:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// ...

@PersistenceContext
EntityManager entityManager;

@Transactional
@Test // no expected exception!
public void falsePositive() {
    updateEntityInJpaPersistenceContext();
    // False positive: an exception will be thrown once the JPA
    // EntityManager is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithEntityManagerFlush() {
    updateEntityInJpaPersistenceContext();
    // Manual flush is required to avoid false positive in test
    entityManager.flush();
}

// ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// ...

@PersistenceContext
lateinit var entityManager:EntityManager

@Transactional
@Test // no expected exception!
fun falsePositive() {
    updateEntityInJpaPersistenceContext()
    // False positive: an exception will be thrown once the JPA
    // EntityManager is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
void updateWithEntityManagerFlush() {
    updateEntityInJpaPersistenceContext()
    // Manual flush is required to avoid false positive in test
    entityManager.flush()
}

// ...</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-executing-sql"><a class="anchor" href="#testcontext-executing-sql"></a>3.5.9. Executing SQL Scripts</h4>
<div class="paragraph">
<p>When writing integration tests against a relational database, it is often beneficial to
execute SQL scripts to modify the database schema or insert test data into tables. The
<code>spring-jdbc</code> module provides support for <em>initializing</em> an embedded or existing database
by executing SQL scripts when the Spring <code>ApplicationContext</code> is loaded. See
<a href="data-access.html#jdbc-embedded-database-support">Embedded database support</a> and
<a href="data-access.html#jdbc-embedded-database-dao-testing">Testing data access logic with an
embedded database</a> for details.</p>
</div>
<div class="paragraph">
<p>Although it is very useful to initialize a database for testing <em>once</em> when the
<code>ApplicationContext</code> is loaded, sometimes it is essential to be able to modify the
database <em>during</em> integration tests. The following sections explain how to execute SQL
scripts programmatically and declaratively during integration tests.</p>
</div>
<div class="sect4">
<h5 id="testcontext-executing-sql-programmatically"><a class="anchor" href="#testcontext-executing-sql-programmatically"></a>Executing SQL scripts programmatically</h5>
<div class="paragraph">
<p>Spring provides the following options for executing SQL scripts programmatically within
integration test methods.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.jdbc.datasource.init.ScriptUtils</code></p>
</li>
<li>
<p><code>org.springframework.jdbc.datasource.init.ResourceDatabasePopulator</code></p>
</li>
<li>
<p><code>org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests</code></p>
</li>
<li>
<p><code>org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ScriptUtils</code> provides a collection of static utility methods for working with SQL
scripts and is mainly intended for internal use within the framework. However, if you
require full control over how SQL scripts are parsed and executed, <code>ScriptUtils</code> may suit
your needs better than some of the other alternatives described later. See the
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/jdbc/datasource/init/ScriptUtils.html">javadoc</a> for individual
methods in <code>ScriptUtils</code> for further details.</p>
</div>
<div class="paragraph">
<p><code>ResourceDatabasePopulator</code> provides an object-based API for programmatically populating,
initializing, or cleaning up a database by using SQL scripts defined in external
resources. <code>ResourceDatabasePopulator</code> provides options for configuring the character
encoding, statement separator, comment delimiters, and error handling flags used when
parsing and running the scripts. Each of the configuration options has a reasonable
default value. See the
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/jdbc/datasource/init/ResourceDatabasePopulator.html">javadoc</a> for
details on default values. To run the scripts configured in a
<code>ResourceDatabasePopulator</code>, you can invoke either the <code>populate(Connection)</code> method to
execute the populator against a <code>java.sql.Connection</code> or the <code>execute(DataSource)</code> method
to execute the populator against a <code>javax.sql.DataSource</code>. The following example
specifies SQL scripts for a test schema and test data, sets the statement separator to
<code>@@</code>, and executes the scripts against a <code>DataSource</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
void databaseTest() {
    ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
    populator.addScripts(
            new ClassPathResource("test-schema.sql"),
            new ClassPathResource("test-data.sql"));
    populator.setSeparator("@@");
    populator.execute(this.dataSource);
    // execute code that uses the test schema and data
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Test
fun databaseTest() {
    val populator = ResourceDatabasePopulator()
    populator.addScripts(
            ClassPathResource("test-schema.sql"),
            ClassPathResource("test-data.sql"))
    populator.setSeparator("@@")
    populator.execute(dataSource)
    // execute code that uses the test schema and data
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>ResourceDatabasePopulator</code> internally delegates to <code>ScriptUtils</code> for parsing
and running SQL scripts. Similarly, the <code>executeSqlScript(..)</code> methods in
<a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a>
and <a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>
internally use a <code>ResourceDatabasePopulator</code> to run SQL scripts. See the javadoc for the
various <code>executeSqlScript(..)</code> methods for further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-executing-sql-declaratively"><a class="anchor" href="#testcontext-executing-sql-declaratively"></a>Executing SQL scripts declaratively with @Sql</h5>
<div class="paragraph">
<p>In addition to the aforementioned mechanisms for running SQL scripts programmatically,
you can declaratively configure SQL scripts in the Spring TestContext Framework.
Specifically, you can declare the <code>@Sql</code> annotation on a test class or test method to
configure individual SQL statements or the resource paths to SQL scripts that should be
run against a given database before or after an integration test method. Support for
<code>@Sql</code> is provided by the <code>SqlScriptsTestExecutionListener</code>, which is enabled by default.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Method-level <code>@Sql</code> declarations override class-level declarations by default. As
of Spring Framework 5.2, however, this behavior may be configured per test class or per
test method via <code>@SqlMergeMode</code>. See
<a href="#testcontext-executing-sql-declaratively-script-merging">Merging and Overriding Configuration with <code>@SqlMergeMode</code></a> for further details.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-resources"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-resources"></a>Path Resource Semantics</h6>
<div class="paragraph">
<p>Each path is interpreted as a Spring <code>Resource</code>. A plain path (for example,
<code>"schema.sql"</code>) is treated as a classpath resource that is relative to the package in
which the test class is defined. A path starting with a slash is treated as an absolute
classpath resource (for example, <code>"/org/example/schema.sql"</code>). A path that references a
URL (for example, a path prefixed with <code>classpath:</code>, <code>file:</code>, <code>http:</code>) is loaded by using
the specified resource protocol.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>@Sql</code> at the class level and at the method level
within a JUnit Jupiter based integration test class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig
@Sql("/test-schema.sql")
class DatabaseTests {

    @Test
    void emptySchemaTest() {
        // execute code that uses the test schema without any test data
    }

    @Test
    @Sql({"/test-schema.sql", "/test-user-data.sql"})
    void userTest() {
        // execute code that uses the test schema and test data
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig
@Sql("/test-schema.sql")
class DatabaseTests {

    @Test
    fun emptySchemaTest() {
        // execute code that uses the test schema without any test data
    }

    @Test
    @Sql("/test-schema.sql", "/test-user-data.sql")
    fun userTest() {
        // execute code that uses the test schema and test data
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-detection"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-detection"></a>Default Script Detection</h6>
<div class="paragraph">
<p>If no SQL scripts or statements are specified, an attempt is made to detect a <code>default</code>
script, depending on where <code>@Sql</code> is declared. If a default cannot be detected, an
<code>IllegalStateException</code> is thrown.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Class-level declaration: If the annotated test class is <code>com.example.MyTest</code>, the
corresponding default script is <code>classpath:com/example/MyTest.sql</code>.</p>
</li>
<li>
<p>Method-level declaration: If the annotated test method is named <code>testMethod()</code> and is
defined in the class <code>com.example.MyTest</code>, the corresponding default script is
<code>classpath:com/example/MyTest.testMethod.sql</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-multiple-annotations"><a class="anchor" href="#testcontext-executing-sql-declaratively-multiple-annotations"></a>Declaring Multiple <code>@Sql</code> Sets</h6>
<div class="paragraph">
<p>If you need to configure multiple sets of SQL scripts for a given test class or test
method but with different syntax configuration, different error handling rules, or
different execution phases per set, you can declare multiple instances of <code>@Sql</code>. With
Java 8, you can use <code>@Sql</code> as a repeatable annotation. Otherwise, you can use the
<code>@SqlGroup</code> annotation as an explicit container for declaring multiple instances of
<code>@Sql</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>@Sql</code> as a repeatable annotation with Java 8:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`"))
@Sql("/test-user-data.sql")
void userTest() {
    // execute code that uses the test schema and test data
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Repeatable annotations with non-SOURCE retention are not yet supported by Kotlin</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the scenario presented in the preceding example, the <code>test-schema.sql</code> script uses a
different syntax for single-line comments.</p>
</div>
<div class="paragraph">
<p>The following example is identical to the preceding example, except that the <code>@Sql</code>
declarations are grouped together within <code>@SqlGroup</code>. With Java 8 and above, the use of
<code>@SqlGroup</code> is optional, but you may need to use <code>@SqlGroup</code> for compatibility with
other JVM languages such as Kotlin.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@SqlGroup({
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}
void userTest() {
    // execute code that uses the test schema and test data
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Test
@SqlGroup(
    Sql("/test-schema.sql", config = SqlConfig(commentPrefix = "`")),
    Sql("/test-user-data.sql"))
fun userTest() {
    // execute code that uses the test schema and test data
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-execution-phases"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-execution-phases"></a>Script Execution Phases</h6>
<div class="paragraph">
<p>By default, SQL scripts are executed before the corresponding test method. However, if
you need to run a particular set of scripts after the test method (for example, to clean
up database state), you can use the <code>executionPhase</code> attribute in <code>@Sql</code>, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@Sql(
    scripts = "create-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED)
)
@Sql(
    scripts = "delete-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED),
    executionPhase = AFTER_TEST_METHOD
)
void userTest() {
    // execute code that needs the test data to be committed
    // to the database outside of the test's transaction
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Test
@SqlGroup(
    Sql("create-test-data.sql",
        config = SqlConfig(transactionMode = ISOLATED)),
    Sql("delete-test-data.sql",
        config = SqlConfig(transactionMode = ISOLATED),
        executionPhase = AFTER_TEST_METHOD))
fun userTest() {
    // execute code that needs the test data to be committed
    // to the database outside of the test's transaction
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>ISOLATED</code> and <code>AFTER_TEST_METHOD</code> are statically imported from
<code>Sql.TransactionMode</code> and <code>Sql.ExecutionPhase</code>, respectively.</p>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-configuration"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-configuration"></a>Script Configuration with <code>@SqlConfig</code></h6>
<div class="paragraph">
<p>You can configure script parsing and error handling by using the <code>@SqlConfig</code> annotation.
When declared as a class-level annotation on an integration test class, <code>@SqlConfig</code>
serves as global configuration for all SQL scripts within the test class hierarchy. When
declared directly by using the <code>config</code> attribute of the <code>@Sql</code> annotation, <code>@SqlConfig</code>
serves as local configuration for the SQL scripts declared within the enclosing <code>@Sql</code>
annotation. Every attribute in <code>@SqlConfig</code> has an implicit default value, which is
documented in the javadoc of the corresponding attribute. Due to the rules defined for
annotation attributes in the Java Language Specification, it is, unfortunately, not
possible to assign a value of <code>null</code> to an annotation attribute. Thus, in order to
support overrides of inherited global configuration, <code>@SqlConfig</code> attributes have an
explicit default value of either <code>""</code> (for Strings), <code>{}</code> (for arrays), or <code>DEFAULT</code> (for
enumerations). This approach lets local declarations of <code>@SqlConfig</code> selectively override
individual attributes from global declarations of <code>@SqlConfig</code> by providing a value other
than <code>""</code>, <code>{}</code>, or <code>DEFAULT</code>. Global <code>@SqlConfig</code> attributes are inherited whenever
local <code>@SqlConfig</code> attributes do not supply an explicit value other than <code>""</code>, <code>{}</code>, or
<code>DEFAULT</code>. Explicit local configuration, therefore, overrides global configuration.</p>
</div>
<div class="paragraph">
<p>The configuration options provided by <code>@Sql</code> and <code>@SqlConfig</code> are equivalent to those
supported by <code>ScriptUtils</code> and <code>ResourceDatabasePopulator</code> but are a superset of those
provided by the <code>&lt;jdbc:initialize-database/&gt;</code> XML namespace element. See the javadoc of
individual attributes in <a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/jdbc/Sql.html"><code>@Sql</code></a> and
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html"><code>@SqlConfig</code></a> for details.</p>
</div>
<div id="testcontext-executing-sql-declaratively-tx" class="paragraph">
<p><strong>Transaction management for <code>@Sql</code></strong></p>
</div>
<div class="paragraph">
<p>By default, the <code>SqlScriptsTestExecutionListener</code> infers the desired transaction
semantics for scripts configured by using <code>@Sql</code>. Specifically, SQL scripts are run
without a transaction, within an existing Spring-managed transaction (for example, a
transaction managed by the <code>TransactionalTestExecutionListener</code> for a test annotated with
<code>@Transactional</code>), or within an isolated transaction, depending on the configured value
of the <code>transactionMode</code> attribute in <code>@SqlConfig</code> and the presence of a
<code>PlatformTransactionManager</code> in the test&#8217;s <code>ApplicationContext</code>. As a bare minimum,
however, a <code>javax.sql.DataSource</code> must be present in the test&#8217;s <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>If the algorithms used by <code>SqlScriptsTestExecutionListener</code> to detect a <code>DataSource</code> and
<code>PlatformTransactionManager</code> and infer the transaction semantics do not suit your needs,
you can specify explicit names by setting the <code>dataSource</code> and <code>transactionManager</code>
attributes of <code>@SqlConfig</code>. Furthermore, you can control the transaction propagation
behavior by setting the <code>transactionMode</code> attribute of <code>@SqlConfig</code> (for example, whether
scripts should be run in an isolated transaction). Although a thorough discussion of all
supported options for transaction management with <code>@Sql</code> is beyond the scope of this
reference manual, the javadoc for
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html"><code>@SqlConfig</code></a> and
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlScriptsTestExecutionListener.html"><code>SqlScriptsTestExecutionListener</code></a>
provide detailed information, and the following example shows a typical testing scenario
that uses JUnit Jupiter and transactional tests with <code>@Sql</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig(TestDatabaseConfig.class)
@Transactional
class TransactionalSqlScriptsTests {

    final JdbcTemplate jdbcTemplate;

    @Autowired
    TransactionalSqlScriptsTests(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    @Sql("/test-data.sql")
    void usersTest() {
        // verify state in test database:
        assertNumUsers(2);
        // execute code that uses the test data...
    }

    int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    void assertNumUsers(int expected) {
        assertEquals(expected, countRowsInTable("user"),
            "Number of rows in the [user] table.");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(TestDatabaseConfig::class)
@Transactional
class TransactionalSqlScriptsTests @Autowired constructor(dataSource: DataSource) {

    val jdbcTemplate: JdbcTemplate = JdbcTemplate(dataSource)

    @Test
    @Sql("/test-data.sql")
    fun usersTest() {
        // verify state in test database:
        assertNumUsers(2)
        // execute code that uses the test data...
    }

    fun countRowsInTable(tableName: String): Int {
        return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName)
    }

    fun assertNumUsers(expected: Int) {
        assertEquals(expected, countRowsInTable("user"),
                "Number of rows in the [user] table.")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that there is no need to clean up the database after the <code>usersTest()</code> method is
run, since any changes made to the database (either within the test method or within the
<code>/test-data.sql</code> script) are automatically rolled back by the
<code>TransactionalTestExecutionListener</code> (see <a href="#testcontext-tx">transaction management</a> for
details).</p>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-merging"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-merging"></a>Merging and Overriding Configuration with <code>@SqlMergeMode</code></h6>
<div class="paragraph">
<p>As of Spring Framework 5.2, it is possible to merge method-level <code>@Sql</code> declarations with
class-level declarations. For example, this allows you to provide the configuration for a
database schema or some common test data once per test class and then provide additional,
use case specific test data per test method. To enable <code>@Sql</code> merging, annotate either
your test class or test method with <code>@SqlMergeMode(MERGE)</code>. To disable merging for a
specific test method (or specific test subclass), you can switch back to the default mode
via <code>@SqlMergeMode(OVERRIDE)</code>. Consult the <a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code> annotation documentation section</a> for examples and further details.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-parallel-test-execution"><a class="anchor" href="#testcontext-parallel-test-execution"></a>3.5.10. Parallel Test Execution</h4>
<div class="paragraph">
<p>Spring Framework 5.0 introduced basic support for executing tests in parallel within a
single JVM when using the Spring TestContext Framework. In general, this means that most
test classes or test methods can be executed in parallel without any changes to test code
or configuration.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For details on how to set up parallel test execution, see the documentation for your
testing framework, build tool, or IDE.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Keep in mind that the introduction of concurrency into your test suite can result in
unexpected side effects, strange runtime behavior, and tests that fail intermittently or
seemingly randomly. The Spring Team therefore provides the following general guidelines
for when not to execute tests in parallel.</p>
</div>
<div class="paragraph">
<p>Do not execute tests in parallel if the tests:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use Spring Framework&#8217;s <code>@DirtiesContext</code> support.</p>
</li>
<li>
<p>Use Spring Boot&#8217;s <code>@MockBean</code> or <code>@SpyBean</code> support.</p>
</li>
<li>
<p>Use JUnit 4&#8217;s <code>@FixMethodOrder</code> support or any testing framework feature
that is designed to ensure that test methods run in a particular order. Note,
however, that this does not apply if entire test classes are executed in parallel.</p>
</li>
<li>
<p>Change the state of shared services or systems such as a database, message broker,
filesystem, and others. This applies to both embedded and external systems.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If parallel test execution fails with an exception stating that the <code>ApplicationContext</code>
for the current test is no longer active, this typically means that the
<code>ApplicationContext</code> was removed from the <code>ContextCache</code> in a different thread.</p>
</div>
<div class="paragraph">
<p>This may be due to the use of <code>@DirtiesContext</code> or due to automatic eviction from the
<code>ContextCache</code>. If <code>@DirtiesContext</code> is the culprit, you either need to find a way to
avoid using <code>@DirtiesContext</code> or exclude such tests from parallel execution. If the
maximum size of the <code>ContextCache</code> has been exceeded, you can increase the maximum size
of the cache. See the discussion on <a href="#testcontext-ctx-management-caching">context caching</a>
for details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Parallel test execution in the Spring TestContext Framework is only possible if
the underlying <code>TestContext</code> implementation provides a copy constructor, as explained in
the javadoc for <a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/context/TestContext.html"><code>TestContext</code></a>. The
<code>DefaultTestContext</code> used in Spring provides such a constructor. However, if you use a
third-party library that provides a custom <code>TestContext</code> implementation, you need to
verify that it is suitable for parallel test execution.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-support-classes"><a class="anchor" href="#testcontext-support-classes"></a>3.5.11. TestContext Framework Support Classes</h4>
<div class="paragraph">
<p>This section describes the various classes that support the Spring TestContext Framework.</p>
</div>
<div class="sect4">
<h5 id="testcontext-junit4-runner"><a class="anchor" href="#testcontext-junit4-runner"></a>Spring JUnit 4 Runner</h5>
<div class="paragraph">
<p>The Spring TestContext Framework offers full integration with JUnit 4 through a custom
runner (supported on JUnit 4.12 or higher). By annotating test classes with
<code>@RunWith(SpringJUnit4ClassRunner.class)</code> or the shorter <code>@RunWith(SpringRunner.class)</code>
variant, developers can implement standard JUnit 4-based unit and integration tests and
simultaneously reap the benefits of the TestContext framework, such as support for
loading application contexts, dependency injection of test instances, transactional test
method execution, and so on. If you want to use the Spring TestContext Framework with an
alternative runner (such as JUnit 4&#8217;s <code>Parameterized</code> runner) or third-party runners
(such as the <code>MockitoJUnitRunner</code>), you can, optionally, use
<a href="#testcontext-junit4-rules">Spring&#8217;s support for JUnit rules</a> instead.</p>
</div>
<div class="paragraph">
<p>The following code listing shows the minimal requirements for configuring a test class to
run with the custom Spring <code>Runner</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@TestExecutionListeners({})
public class SimpleTest {

    @Test
    public void testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@RunWith(SpringRunner::class)
@TestExecutionListeners
class SimpleTest {

    @Test
    fun testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, <code>@TestExecutionListeners</code> is configured with an empty list, to
disable the default listeners, which otherwise would require an <code>ApplicationContext</code> to
be configured through <code>@ContextConfiguration</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-junit4-rules"><a class="anchor" href="#testcontext-junit4-rules"></a>Spring JUnit 4 Rules</h5>
<div class="paragraph">
<p>The <code>org.springframework.test.context.junit4.rules</code> package provides the following JUnit
4 rules (supported on JUnit 4.12 or higher):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SpringClassRule</code></p>
</li>
<li>
<p><code>SpringMethodRule</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>SpringClassRule</code> is a JUnit <code>TestRule</code> that supports class-level features of the Spring
TestContext Framework, whereas <code>SpringMethodRule</code> is a JUnit <code>MethodRule</code> that supports
instance-level and method-level features of the Spring TestContext Framework.</p>
</div>
<div class="paragraph">
<p>In contrast to the <code>SpringRunner</code>, Spring&#8217;s rule-based JUnit support has the advantage of
being independent of any <code>org.junit.runner.Runner</code> implementation and can, therefore, be
combined with existing alternative runners (such as JUnit 4&#8217;s <code>Parameterized</code>) or
third-party runners (such as the <code>MockitoJUnitRunner</code>).</p>
</div>
<div class="paragraph">
<p>To support the full functionality of the TestContext framework, you must combine a
<code>SpringClassRule</code> with a <code>SpringMethodRule</code>. The following example shows the proper way
to declare these rules in an integration test:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Optionally specify a non-Spring Runner via @RunWith(...)
@ContextConfiguration
public class IntegrationTest {

    @ClassRule
    public static final SpringClassRule springClassRule = new SpringClassRule();

    @Rule
    public final SpringMethodRule springMethodRule = new SpringMethodRule();

    @Test
    public void testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Optionally specify a non-Spring Runner via @RunWith(...)
@ContextConfiguration
class IntegrationTest {

    @Rule
    val springMethodRule = SpringMethodRule()

    @Test
    fun testMethod() {
        // execute test logic...
    }

    companion object {
        @ClassRule
        val springClassRule = SpringClassRule()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-support-classes-junit4"><a class="anchor" href="#testcontext-support-classes-junit4"></a>JUnit 4 Support Classes</h5>
<div class="paragraph">
<p>The <code>org.springframework.test.context.junit4</code> package provides the following support
classes for JUnit 4-based test cases (supported on JUnit 4.12 or higher):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AbstractJUnit4SpringContextTests</code></p>
</li>
<li>
<p><code>AbstractTransactionalJUnit4SpringContextTests</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>AbstractJUnit4SpringContextTests</code> is an abstract base test class that integrates the
Spring TestContext Framework with explicit <code>ApplicationContext</code> testing support in a
JUnit 4 environment. When you extend <code>AbstractJUnit4SpringContextTests</code>, you can access a
<code>protected</code> <code>applicationContext</code> instance variable that you can use to perform explicit
bean lookups or to test the state of the context as a whole.</p>
</div>
<div class="paragraph">
<p><code>AbstractTransactionalJUnit4SpringContextTests</code> is an abstract transactional extension of
<code>AbstractJUnit4SpringContextTests</code> that adds some convenience functionality for JDBC
access. This class expects a <code>javax.sql.DataSource</code> bean and a
<code>PlatformTransactionManager</code> bean to be defined in the <code>ApplicationContext</code>. When you
extend <code>AbstractTransactionalJUnit4SpringContextTests</code>, you can access a <code>protected</code>
<code>jdbcTemplate</code> instance variable that you can use to run SQL statements to query the
database. You can use such queries to confirm database state both before and after
running database-related application code, and Spring ensures that such queries run in
the scope of the same transaction as the application code. When used in conjunction with
an ORM tool, be sure to avoid <a href="#testcontext-tx-false-positives">false positives</a>.
As mentioned in <a href="#integration-testing-support-jdbc">JDBC Testing Support</a>,
<code>AbstractTransactionalJUnit4SpringContextTests</code> also provides convenience methods that
delegate to methods in <code>JdbcTestUtils</code> by using the aforementioned <code>jdbcTemplate</code>.
Furthermore, <code>AbstractTransactionalJUnit4SpringContextTests</code> provides an
<code>executeSqlScript(..)</code> method for running SQL scripts against the configured <code>DataSource</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
These classes are a convenience for extension. If you do not want your test classes
to be tied to a Spring-specific class hierarchy, you can configure your own custom test
classes by using <code>@RunWith(SpringRunner.class)</code> or <a href="#testcontext-junit4-rules">Spring&#8217;s
JUnit rules</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-junit-jupiter-extension"><a class="anchor" href="#testcontext-junit-jupiter-extension"></a>SpringExtension for JUnit Jupiter</h5>
<div class="paragraph">
<p>The Spring TestContext Framework offers full integration with the JUnit Jupiter testing
framework, introduced in JUnit 5. By annotating test classes with
<code>@ExtendWith(SpringExtension.class)</code>, you can implement standard JUnit Jupiter-based unit
and integration tests and simultaneously reap the benefits of the TestContext framework,
such as support for loading application contexts, dependency injection of test instances,
transactional test method execution, and so on.</p>
</div>
<div class="paragraph">
<p>Furthermore, thanks to the rich extension API in JUnit Jupiter, Spring provides the
following features above and beyond the feature set that Spring supports for JUnit 4 and
TestNG:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dependency injection for test constructors, test methods, and test lifecycle callback
methods. See <a href="#testcontext-junit-jupiter-di">Dependency Injection with <code>SpringExtension</code></a> for further details.</p>
</li>
<li>
<p>Powerful support for <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-conditions">conditional
test execution</a> based on SpEL expressions, environment variables, system properties,
and so on. See the documentation for <code>@EnabledIf</code> and <code>@DisabledIf</code> in
<a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter Testing Annotations</a> for further details and examples.</p>
</li>
<li>
<p>Custom composed annotations that combine annotations from Spring and JUnit Jupiter. See
the <code>@TransactionalDevTestConfig</code> and <code>@TransactionalIntegrationTest</code> examples in
<a href="#integration-testing-annotations-meta">Meta-Annotation Support for Testing</a> for further details.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following code listing shows how to configure a test class to use the
<code>SpringExtension</code> in conjunction with <code>@ContextConfiguration</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Instructs JUnit Jupiter to extend the test with Spring support.
@ExtendWith(SpringExtension.class)
// Instructs Spring to load an ApplicationContext from TestConfig.class
@ContextConfiguration(classes = TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Instructs JUnit Jupiter to extend the test with Spring support.
@ExtendWith(SpringExtension::class)
// Instructs Spring to load an ApplicationContext from TestConfig::class
@ContextConfiguration(classes = [TestConfig::class])
class SimpleTests {

    @Test
    fun testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since you can also use annotations in JUnit 5 as meta-annotations, Spring provides the
<code>@SpringJUnitConfig</code> and <code>@SpringJUnitWebConfig</code> composed annotations to simplify the
configuration of the test <code>ApplicationContext</code> and JUnit Jupiter.</p>
</div>
<div class="paragraph">
<p>The following example uses <code>@SpringJUnitConfig</code> to reduce the amount of configuration
used in the previous example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load an ApplicationContext from TestConfig.class
@SpringJUnitConfig(TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load an ApplicationContext from TestConfig.class
@SpringJUnitConfig(TestConfig::class)
class SimpleTests {

    @Test
    fun testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, the following example uses <code>@SpringJUnitWebConfig</code> to create a
<code>WebApplicationContext</code> for use with JUnit Jupiter:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load a WebApplicationContext from TestWebConfig.class
@SpringJUnitWebConfig(TestWebConfig.class)
class SimpleWebTests {

    @Test
    void testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load a WebApplicationContext from TestWebConfig::class
@SpringJUnitWebConfig(TestWebConfig::class)
class SimpleWebTests {

    @Test
    fun testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the documentation for <code>@SpringJUnitConfig</code> and <code>@SpringJUnitWebConfig</code> in
<a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter Testing Annotations</a> for further details.</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-junit-jupiter-di"><a class="anchor" href="#testcontext-junit-jupiter-di"></a>Dependency Injection with <code>SpringExtension</code></h5>
<div class="paragraph">
<p><code>SpringExtension</code> implements the
<a href="https://junit.org/junit5/docs/current/user-guide/#extensions-parameter-resolution"><code>ParameterResolver</code></a>
extension API from JUnit Jupiter, which lets Spring provide dependency injection for test
constructors, test methods, and test lifecycle callback methods.</p>
</div>
<div class="paragraph">
<p>Specifically, <code>SpringExtension</code> can inject dependencies from the test&#8217;s
<code>ApplicationContext</code> into test constructors and methods that are annotated with
<code>@BeforeAll</code>, <code>@AfterAll</code>, <code>@BeforeEach</code>, <code>@AfterEach</code>, <code>@Test</code>, <code>@RepeatedTest</code>,
<code>@ParameterizedTest</code>, and others.</p>
</div>
<div class="sect5">
<h6 id="testcontext-junit-jupiter-di-constructor"><a class="anchor" href="#testcontext-junit-jupiter-di-constructor"></a>Constructor Injection</h6>
<div class="paragraph">
<p>If a specific parameter in a constructor for a JUnit Jupiter test class is of type
<code>ApplicationContext</code> (or a sub-type thereof) or is annotated or meta-annotated with
<code>@Autowired</code>, <code>@Qualifier</code>, or <code>@Value</code>, Spring injects the value for that specific
parameter with the corresponding bean or value from the test&#8217;s <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>Spring can also be configured to autowire all arguments for a test class constructor if
the constructor is considered to be <em>autowirable</em>. A constructor is considered to be
autowirable if one of the following conditions is met (in order of precedence).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The constructor is annotated with <code>@Autowired</code>.</p>
</li>
<li>
<p><code>@TestConstructor</code> is present or meta-present on the test class with the <code>autowireMode</code>
attribute set to <code>ALL</code>.</p>
</li>
<li>
<p>The default <em>test constructor autowire mode</em> has been changed to <code>ALL</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a> for details on the use of
<code>@TestConstructor</code> and how to change the global <em>test constructor autowire mode</em>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If the constructor for a test class is considered to be <em>autowirable</em>, Spring
assumes the responsibility for resolving arguments for all parameters in the constructor.
Consequently, no other <code>ParameterResolver</code> registered with JUnit Jupiter can resolve
parameters for such a constructor.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Constructor injection for test classes must not be used in conjunction with JUnit
Jupiter&#8217;s <code>@TestInstance(PER_CLASS)</code> support if <code>@DirtiesContext</code> is used to close the
test&#8217;s <code>ApplicationContext</code> before or after test methods.</p>
</div>
<div class="paragraph">
<p>The reason is that <code>@TestInstance(PER_CLASS)</code> instructs JUnit Jupiter to cache the test
instance between test method invocations. Consequently, the test instance will retain
references to beans that were originally injected from an <code>ApplicationContext</code> that has
been subsequently closed. Since the constructor for the test class will only be invoked
once in such scenarios, dependency injection will not occur again, and subsequent tests
will interact with beans from the closed <code>ApplicationContext</code> which may result in errors.</p>
</div>
<div class="paragraph">
<p>To use <code>@DirtiesContext</code> with "before test method" or "after test method" modes in
conjunction with <code>@TestInstance(PER_CLASS)</code>, one must configure dependencies from Spring
to be supplied via field or setter injection so that they can be re-injected between test
method invocations.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the following example, Spring injects the <code>OrderService</code> bean from the
<code>ApplicationContext</code> loaded from <code>TestConfig.class</code> into the
<code>OrderServiceIntegrationTests</code> constructor.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    @Autowired
    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests @Autowired constructor(private val orderService: OrderService){
    // tests that use the injected OrderService
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that this feature lets test dependencies be <code>final</code> and therefore immutable.</p>
</div>
<div class="paragraph">
<p>If the <code>spring.test.constructor.autowire.mode</code> property is to <code>all</code> (see
<a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a>), we can omit the declaration of
<code>@Autowired</code> on the constructor in the previous example, resulting in the following.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests(val orderService:OrderService) {
    // tests that use the injected OrderService
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-junit-jupiter-di-method"><a class="anchor" href="#testcontext-junit-jupiter-di-method"></a>Method Injection</h6>
<div class="paragraph">
<p>If a parameter in a JUnit Jupiter test method or test lifecycle callback method is of
type <code>ApplicationContext</code> (or a sub-type thereof) or is annotated or meta-annotated with
<code>@Autowired</code>, <code>@Qualifier</code>, or <code>@Value</code>, Spring injects the value for that specific
parameter with the corresponding bean from the test&#8217;s <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>In the following example, Spring injects the <code>OrderService</code> from the <code>ApplicationContext</code>
loaded from <code>TestConfig.class</code> into the <code>deleteOrder()</code> test method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @Test
    void deleteOrder(@Autowired OrderService orderService) {
        // use orderService from the test's ApplicationContext
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests {

    @Test
    fun deleteOrder(@Autowired orderService: OrderService) {
        // use orderService from the test's ApplicationContext
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Due to the robustness of the <code>ParameterResolver</code> support in JUnit Jupiter, you can also
have multiple dependencies injected into a single method, not only from Spring but also
from JUnit Jupiter itself or other third-party extensions.</p>
</div>
<div class="paragraph">
<p>The following example shows how to have both Spring and JUnit Jupiter inject dependencies
into the <code>placeOrderRepeatedly()</code> test method simultaneously.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @RepeatedTest(10)
    void placeOrderRepeatedly(RepetitionInfo repetitionInfo,
            @Autowired OrderService orderService) {

        // use orderService from the test's ApplicationContext
        // and repetitionInfo from JUnit Jupiter
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests {

    @RepeatedTest(10)
    fun placeOrderRepeatedly(repetitionInfo:RepetitionInfo, @Autowired orderService:OrderService) {

        // use orderService from the test's ApplicationContext
        // and repetitionInfo from JUnit Jupiter
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the use of <code>@RepeatedTest</code> from JUnit Jupiter lets the test method gain access
to the <code>RepetitionInfo</code>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-support-classes-testng"><a class="anchor" href="#testcontext-support-classes-testng"></a>TestNG Support Classes</h5>
<div class="paragraph">
<p>The <code>org.springframework.test.context.testng</code> package provides the following support
classes for TestNG based test cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AbstractTestNGSpringContextTests</code></p>
</li>
<li>
<p><code>AbstractTransactionalTestNGSpringContextTests</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>AbstractTestNGSpringContextTests</code> is an abstract base test class that integrates the
Spring TestContext Framework with explicit <code>ApplicationContext</code> testing support in a
TestNG environment. When you extend <code>AbstractTestNGSpringContextTests</code>, you can access a
<code>protected</code> <code>applicationContext</code> instance variable that you can use to perform explicit
bean lookups or to test the state of the context as a whole.</p>
</div>
<div class="paragraph">
<p><code>AbstractTransactionalTestNGSpringContextTests</code> is an abstract transactional extension of
<code>AbstractTestNGSpringContextTests</code> that adds some convenience functionality for JDBC
access. This class expects a <code>javax.sql.DataSource</code> bean and a
<code>PlatformTransactionManager</code> bean to be defined in the <code>ApplicationContext</code>. When you
extend <code>AbstractTransactionalTestNGSpringContextTests</code>, you can access a <code>protected</code>
<code>jdbcTemplate</code> instance variable that you can use to execute SQL statements to query the
database. You can use such queries to confirm database state both before and after
running database-related application code, and Spring ensures that such queries run in
the scope of the same transaction as the application code. When used in conjunction with
an ORM tool, be sure to avoid <a href="#testcontext-tx-false-positives">false positives</a>.
As mentioned in <a href="#integration-testing-support-jdbc">JDBC Testing Support</a>,
<code>AbstractTransactionalTestNGSpringContextTests</code> also provides convenience methods that
delegate to methods in <code>JdbcTestUtils</code> by using the aforementioned <code>jdbcTemplate</code>.
Furthermore, <code>AbstractTransactionalTestNGSpringContextTests</code> provides an
<code>executeSqlScript(..)</code> method for running SQL scripts against the configured <code>DataSource</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
These classes are a convenience for extension. If you do not want your test classes
to be tied to a Spring-specific class hierarchy, you can configure your own custom test
classes by using <code>@ContextConfiguration</code>, <code>@TestExecutionListeners</code>, and so on and by
manually instrumenting your test class with a <code>TestContextManager</code>. See the source code
of <code>AbstractTestNGSpringContextTests</code> for an example of how to instrument your test class.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-mvc-test-framework"><a class="anchor" href="#spring-mvc-test-framework"></a>3.6. Spring MVC Test Framework</h3>
<div class="paragraph">
<p>The Spring MVC Test framework provides first class support for testing Spring MVC code
with a fluent API that you can use with JUnit, TestNG, or any other testing framework. It
is built on the <a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/mock/web/package-summary.html">Servlet API mock objects</a>
from the <code>spring-test</code> module and, hence, does not use a running Servlet container. It
uses the <code>DispatcherServlet</code> to provide full Spring MVC runtime behavior and provides
support for loading actual Spring configuration with the TestContext framework in
addition to a standalone mode, in which you can manually instantiate controllers and test
them one at a time.</p>
</div>
<div class="paragraph">
<p>Spring MVC Test also provides client-side support for testing code that uses the
<code>RestTemplate</code>. Client-side tests mock the server responses and also do not use a running
server.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring Boot provides an option to write full, end-to-end integration tests that
include a running server. If this is your goal, see the
<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing">Spring Boot Reference Guide</a>.
For more information on the differences between out-of-container and end-to-end
integration tests, see <a href="#spring-mvc-test-vs-end-to-end-integration-tests">Spring MVC Test vs End-to-End Tests</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="spring-mvc-test-server"><a class="anchor" href="#spring-mvc-test-server"></a>3.6.1. Server-Side Tests</h4>
<div class="paragraph">
<p>You can write a plain unit test for a Spring MVC controller by using JUnit or TestNG. To
do so, instantiate the controller, inject it with mocked or stubbed dependencies, and
call its methods (passing <code>MockHttpServletRequest</code>, <code>MockHttpServletResponse</code>, and
others, as necessary). However, when writing such a unit test, much remains untested: for
example, request mappings, data binding, type conversion, validation, and much more.
Furthermore, other controller methods such as <code>@InitBinder</code>, <code>@ModelAttribute</code>, and
<code>@ExceptionHandler</code> may also be invoked as part of the request processing lifecycle.</p>
</div>
<div class="paragraph">
<p>The goal of Spring MVC Test is to provide an effective way to test controllers by
performing requests and generating responses through the actual <code>DispatcherServlet</code>.</p>
</div>
<div class="paragraph">
<p>Spring MVC Test builds on the familiar <a href="#mock-objects-servlet">&#8220;mock&#8221; implementations of
the Servlet API</a> available in the <code>spring-test</code> module. This allows performing requests
and generating responses without the need for running in a Servlet container. For the
most part, everything should work as it does at runtime with a few notable exceptions, as
explained in <a href="#spring-mvc-test-vs-end-to-end-integration-tests">Spring MVC Test vs End-to-End Tests</a>. The following JUnit
Jupiter-based example uses Spring MVC Test:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.<strong>;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.</strong>;

@SpringJUnitWebConfig(locations = "test-servlet-context.xml")
class ExampleTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    @Test
    void getAccount() throws Exception {
        this.mockMvc.perform(get("/accounts/1")
                .accept(MediaType.APPLICATION_JSON))
            .andExpect(status().isOk())
            .andExpect(content().contentType("application/json"))
            .andExpect(jsonPath("$.name").value("Lee"));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.test.web.servlet.get

@SpringJUnitWebConfig(locations = ["test-servlet-context.xml"])
class ExampleTests {

    lateinit var mockMvc: MockMvc

    @BeforeEach
    fun setup(wac: WebApplicationContext) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()
    }

    @Test
    fun getAccount() {
        mockMvc.get("/accounts/1") {
            accept = MediaType.APPLICATION_JSON
        }.andExpect {
            status { isOk }
            content { contentType(MediaType.APPLICATION_JSON) }
            jsonPath("$.name") { value("Lee") }
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A dedicated <a href="languages.html#mockmvc-dsl">MockMvc DSL</a> is available in Kotlin
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The preceding test relies on the <code>WebApplicationContext</code> support of the TestContext
framework to load Spring configuration from an XML configuration file located in the same
package as the test class, but Java-based and Groovy-based configuration are also
supported. See these
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples/context">sample tests</a>.</p>
</div>
<div class="paragraph">
<p>The <code>MockMvc</code> instance is used to perform a <code>GET</code> request to <code>/accounts/1</code> and verify
that the resulting response has status 200, the content type is <code>application/json</code>, and
the response body has a JSON property called <code>name</code> with the value <code>Lee</code>. The <code>jsonPath</code>
syntax is supported through the Jayway <a href="https://github.com/jayway/JsonPath">JsonPath
project</a>. Many other options for verifying the result of the performed request are
discussed later in this document.</p>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-static-imports"><a class="anchor" href="#spring-mvc-test-server-static-imports"></a>Static Imports</h5>
<div class="paragraph">
<p>The fluent API in the example from the <a href="#spring-mvc-test-server">preceding section</a>
requires a few static imports, such as <code>MockMvcRequestBuilders.*</code>,
<code>MockMvcResultMatchers.*</code>, and <code>MockMvcBuilders.*</code>. An easy way to find
these classes is to search for types that match <code>MockMvc*</code>. If you use Eclipse or the
<a href="https://spring.io/tools">Spring Tools for Eclipse</a>, be sure to add them as &#8220;favorite static members&#8221; in
the Eclipse preferences under Java &#8594; Editor &#8594; Content Assist &#8594; Favorites. Doing so
lets you use content assist after typing the first character of the static method name.
Other IDEs (such as IntelliJ) may not require any additional configuration. Check the
support for code completion on static members.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-setup-options"><a class="anchor" href="#spring-mvc-test-server-setup-options"></a>Setup Choices</h5>
<div class="paragraph">
<p>You have two main options for creating an instance of <code>MockMvc</code>. The first is to load
Spring MVC configuration through the TestContext framework, which loads the Spring
configuration and injects a <code>WebApplicationContext</code> into the test to use to build a
<code>MockMvc</code> instance. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitWebConfig(locations = "my-servlet-context.xml")
class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
    }

    // ...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitWebConfig(locations = ["my-servlet-context.xml"])
class MyWebTests {

    lateinit var mockMvc: MockMvc

    @BeforeEach
    fun setup(wac: WebApplicationContext) {
        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your second option is to manually create a controller instance without loading Spring
configuration. Instead, basic default configuration, roughly comparable to that of the
MVC JavaConfig or the MVC namespace, is automatically created. You can customize it to a
degree. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup() {
        this.mockMvc = MockMvcBuilders.standaloneSetup(new AccountController()).build();
    }

    // ...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyWebTests {

    lateinit var mockMvc : MockMvc

    @BeforeEach
    fun setup() {
        mockMvc = MockMvcBuilders.standaloneSetup(AccountController()).build()
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which setup option should you use?</p>
</div>
<div class="paragraph">
<p>The <code>webAppContextSetup</code> loads your actual Spring MVC configuration, resulting in a more
complete integration test. Since the TestContext framework caches the loaded Spring
configuration, it helps keep tests running fast, even as you introduce more tests in your
test suite. Furthermore, you can inject mock services into controllers through Spring
configuration to remain focused on testing the web layer. The following example declares
a mock service with Mockito:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="accountService" class="org.mockito.Mockito" factory-method="mock"&gt;
    &lt;constructor-arg value="org.example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then inject the mock service into the test to set up and verify your
expectations, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitWebConfig(locations = "test-servlet-context.xml")
class AccountTests {

    @Autowired
    AccountService accountService;

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    // ...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitWebConfig(locations = ["test-servlet-context.xml"])
class AccountTests {

    @Autowired
    lateinit var accountService: AccountService

    lateinit mockMvc: MockMvc

    @BeforeEach
    fun setup(wac: WebApplicationContext) {
        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>standaloneSetup</code>, on the other hand, is a little closer to a unit test. It tests one
controller at a time. You can manually inject the controller with mock dependencies, and
it does not involve loading Spring configuration. Such tests are more focused on style
and make it easier to see which controller is being tested, whether any specific Spring
MVC configuration is required to work, and so on. The <code>standaloneSetup</code> is also a very
convenient way to write ad-hoc tests to verify specific behavior or to debug an issue.</p>
</div>
<div class="paragraph">
<p>As with most &#8220;integration versus unit testing&#8221; debates, there is no right or wrong
answer. However, using the <code>standaloneSetup</code> does imply the need for additional
<code>webAppContextSetup</code> tests in order to verify your Spring MVC configuration.
Alternatively, you can write all your tests with <code>webAppContextSetup</code>, in order to always
test against your actual Spring MVC configuration.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-setup-steps"><a class="anchor" href="#spring-mvc-test-server-setup-steps"></a>Setup Features</h5>
<div class="paragraph">
<p>No matter which MockMvc builder you use, all <code>MockMvcBuilder</code> implementations provide
some common and very useful features. For example, you can declare an <code>Accept</code> header for
all requests and expect a status of 200 as well as a <code>Content-Type</code> header in all
responses, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// static import of MockMvcBuilders.standaloneSetup

MockMvc mockMvc = standaloneSetup(new MusicController())
    .defaultRequest(get("/").accept(MediaType.APPLICATION_JSON))
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType("application/json;charset=UTF-8"))
    .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, third-party frameworks (and applications) can pre-package setup
instructions, such as those in a <code>MockMvcConfigurer</code>. The Spring Framework has one such
built-in implementation that helps to save and re-use the HTTP session across requests.
You can use it as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// static import of SharedHttpSessionConfigurer.sharedHttpSession

MockMvc mockMvc = MockMvcBuilders.standaloneSetup(new TestController())
        .apply(sharedHttpSession())
        .build();

// Use mockMvc to perform requests...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the javadoc for
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/test/web/servlet/setup/ConfigurableMockMvcBuilder.html"><code>ConfigurableMockMvcBuilder</code></a>
for a list of all MockMvc builder features or use the IDE to explore the available options.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-performing-requests"><a class="anchor" href="#spring-mvc-test-server-performing-requests"></a>Performing Requests</h5>
<div class="paragraph">
<p>You can perform requests that use any HTTP method, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mockMvc.perform(post("/hotels/{id}", 42).accept(MediaType.APPLICATION_JSON));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.test.web.servlet.post

mockMvc.post("/hotels/{id}", 42) {
    accept = MediaType.APPLICATION_JSON
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also perform file upload requests that internally use
<code>MockMultipartHttpServletRequest</code> so that there is no actual parsing of a multipart
request. Rather, you have to set it up to be similar to the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mockMvc.perform(multipart("/doc").file("a1", "ABC".getBytes("UTF-8")));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.test.web.servlet.multipart

mockMvc.multipart("/doc") {
    file("a1", "ABC".toByteArray(charset("UTF8")))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can specify query parameters in URI template style, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mockMvc.perform(get("/hotels?thing={thing}", "somewhere"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">mockMvc.get("/hotels?thing={thing}", "somewhere")</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also add Servlet request parameters that represent either query or form
parameters, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mockMvc.perform(get("/hotels").param("thing", "somewhere"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.test.web.servlet.get

mockMvc.get("/hotels") {
    param("thing", "somewhere")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If application code relies on Servlet request parameters and does not check the query
string explicitly (as is most often the case), it does not matter which option you use.
Keep in mind, however, that query parameters provided with the URI template are decoded
while request parameters provided through the <code>param(&#8230;&#8203;)</code> method are expected to already
be decoded.</p>
</div>
<div class="paragraph">
<p>In most cases, it is preferable to leave the context path and the Servlet path out of the
request URI. If you must test with the full request URI, be sure to set the <code>contextPath</code>
and <code>servletPath</code> accordingly so that request mappings work, as the following example
shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mockMvc.perform(get("/app/main/hotels/{id}").contextPath("/app").servletPath("/main"))</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.test.web.servlet.get

mockMvc.get("/app/main/hotels/{id}") {
    contextPath = "/app"
    servletPath = "/main"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, it would be cumbersome to set the <code>contextPath</code> and
<code>servletPath</code> with every performed request. Instead, you can set up default request
properties, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup() {
        mockMvc = standaloneSetup(new AccountController())
            .defaultRequest(get("/")
            .contextPath("/app").servletPath("/main")
            .accept(MediaType.APPLICATION_JSON)).build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding properties affect every request performed through the <code>MockMvc</code> instance.
If the same property is also specified on a given request, it overrides the default
value. That is why the HTTP method and URI in the default request do not matter, since
they must be specified on every request.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-defining-expectations"><a class="anchor" href="#spring-mvc-test-server-defining-expectations"></a>Defining Expectations</h5>
<div class="paragraph">
<p>You can define expectations by appending one or more <code>.andExpect(..)</code> calls after
performing a request, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mockMvc.perform(get("/accounts/1")).andExpect(status().isOk());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.test.web.servlet.get

mockMvc.get("/accounts/1").andExpect {
    status().isOk()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MockMvcResultMatchers.*</code> provides a number of expectations, some of which are further
nested with more detailed expectations.</p>
</div>
<div class="paragraph">
<p>Expectations fall in two general categories. The first category of assertions verifies
properties of the response (for example, the response status, headers, and content).
These are the most important results to assert.</p>
</div>
<div class="paragraph">
<p>The second category of assertions goes beyond the response. These assertions let you
inspect Spring MVC specific aspects, such as which controller method processed the
request, whether an exception was raised and handled, what the content of the model is,
what view was selected, what flash attributes were added, and so on. They also let you
inspect Servlet specific aspects, such as request and session attributes.</p>
</div>
<div class="paragraph">
<p>The following test asserts that binding or validation failed:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mockMvc.perform(post("/persons"))
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors("person"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.test.web.servlet.post

mockMvc.post("/persons").andExpect {
    status().isOk()
    model {
        attributeHasErrors("person")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Many times, when writing tests, it is useful to dump the results of the performed
request. You can do so as follows, where <code>print()</code> is a static import from
<code>MockMvcResultHandlers</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mockMvc.perform(post("/persons"))
    .andDo(print())
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors("person"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.test.web.servlet.post

mockMvc.post("/persons").andDo {
        print()
    }.andExpect {
        status().isOk()
        model {
            attributeHasErrors("person")
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>As long as request processing does not cause an unhandled exception, the <code>print()</code> method
prints all the available result data to <code>System.out</code>. There is also a <code>log()</code> method and
two additional variants of the <code>print()</code> method, one that accepts an <code>OutputStream</code> and
one that accepts a <code>Writer</code>. For example, invoking <code>print(System.err)</code> prints the result
data to <code>System.err</code>, while invoking <code>print(myWriter)</code> prints the result data to a custom
writer. If you want to have the result data logged instead of printed, you can invoke the
<code>log()</code> method, which logs the result data as a single <code>DEBUG</code> message under the
<code>org.springframework.test.web.servlet.result</code> logging category.</p>
</div>
<div class="paragraph">
<p>In some cases, you may want to get direct access to the result and verify something that
cannot be verified otherwise. This can be achieved by appending <code>.andReturn()</code> after all
other expectations, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MvcResult mvcResult = mockMvc.perform(post("/persons")).andExpect(status().isOk()).andReturn();
// ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">var mvcResult = mockMvc.post("/persons").andExpect { status().isOk() }.andReturn()
// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>If all tests repeat the same expectations, you can set up common expectations once when
building the <code>MockMvc</code> instance, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">standaloneSetup(new SimpleController())
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType("application/json;charset=UTF-8"))
    .build()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that common expectations are always applied and cannot be overridden without
creating a separate <code>MockMvc</code> instance.</p>
</div>
<div class="paragraph">
<p>When a JSON response content contains hypermedia links created with
<a href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a>, you can verify the
resulting links by using JsonPath expressions, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mockMvc.perform(get("/people").accept(MediaType.APPLICATION_JSON))
    .andExpect(jsonPath("$.links[?(@.rel == 'self')].href").value("http://localhost:8080/people"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">mockMvc.get("/people") {
    accept(MediaType.APPLICATION_JSON)
}.andExpect {
    jsonPath("$.links[?(@.rel == 'self')].href") {
        value("http://localhost:8080/people")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When XML response content contains hypermedia links created with
<a href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a>, you can verify the
resulting links by using XPath expressions:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Map&lt;String, String&gt; ns = Collections.singletonMap("ns", "http://www.w3.org/2005/Atom");
mockMvc.perform(get("/handle").accept(MediaType.APPLICATION_XML))
    .andExpect(xpath("/person/ns:link[@rel='self']/@href", ns).string("http://localhost:8080/people"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val ns = mapOf("ns" to "http://www.w3.org/2005/Atom")
mockMvc.get("/handle") {
    accept(MediaType.APPLICATION_XML)
}.andExpect {
    xpath("/person/ns:link[@rel='self']/@href", ns) {
        string("http://localhost:8080/people")
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-async-requests"><a class="anchor" href="#spring-mvc-test-async-requests"></a>Async Requests</h5>
<div class="paragraph">
<p>Servlet 3.0 asynchronous requests,
<a href="web.html#mvc-ann-async">supported in Spring MVC</a>, work by exiting the Servlet container
thread and allowing the application to compute the response asynchronously, after which
an async dispatch is made to complete processing on a Servlet container thread.</p>
</div>
<div class="paragraph">
<p>In Spring MVC Test, async requests can be tested by asserting the produced async value
first, then manually performing the async dispatch, and finally verifying the response.
Below is an example test for controller methods that return <code>DeferredResult</code>, <code>Callable</code>,
or reactive type such as Reactor <code>Mono</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
void test() throws Exception {
    MvcResult mvcResult = this.mockMvc.perform(get("/path"))
            .andExpect(status().isOk()) <i class="conum" data-value="1"></i><b>(1)</b>
            .andExpect(request().asyncStarted()) <i class="conum" data-value="2"></i><b>(2)</b>
            .andExpect(request().asyncResult("body")) <i class="conum" data-value="3"></i><b>(3)</b>
            .andReturn();

    this.mockMvc.perform(asyncDispatch(mvcResult)) <i class="conum" data-value="4"></i><b>(4)</b>
            .andExpect(status().isOk()) <i class="conum" data-value="5"></i><b>(5)</b>
            .andExpect(content().string("body"));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Check response status is still unchanged</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Async processing must have started</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Wait and assert the async result</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Manually perform an ASYNC dispatch (as there is no running container)</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Verify the final response</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Test
fun test() {
    var mvcResult = mockMvc.get("/path").andExpect {
        status().isOk() <i class="conum" data-value="1"></i><b>(1)</b>
        request { asyncStarted() } <i class="conum" data-value="2"></i><b>(2)</b>
        // TODO Remove unused generic parameter
        request { asyncResult&lt;Nothing&gt;("body") } <i class="conum" data-value="3"></i><b>(3)</b>
    }.andReturn()


    mockMvc.perform(asyncDispatch(mvcResult)) <i class="conum" data-value="4"></i><b>(4)</b>
            .andExpect {
                status().isOk() <i class="conum" data-value="5"></i><b>(5)</b>
                content().string("body")
            }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Check response status is still unchanged</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Async processing must have started</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Wait and assert the async result</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Manually perform an ASYNC dispatch (as there is no running container)</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Verify the final response</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-vs-streaming-response"><a class="anchor" href="#spring-mvc-test-vs-streaming-response"></a>Streaming Responses</h5>
<div class="paragraph">
<p>There are no options built into Spring MVC Test for container-less testing of streaming
responses. Applications that make use of
<a href="web.html#mvc-ann-async-http-streaming">Spring MVC streaming</a> options can use the
<a href="#webtestclient-stream">WebTestClient</a> to perform end-to-end, integration
tests against a running server. This is also supported in Spring Boot where you can
<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-with-running-server">test a running server</a>
with <code>WebTestClient</code>. One extra advantage is the ability to use the <code>StepVerifier</code> from
project Reactor that allows declaring expectations on a stream of data.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-filters"><a class="anchor" href="#spring-mvc-test-server-filters"></a>Filter Registrations</h5>
<div class="paragraph">
<p>When setting up a <code>MockMvc</code> instance, you can register one or more Servlet <code>Filter</code>
instances, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Registered filters are invoked through the <code>MockFilterChain</code> from <code>spring-test</code>, and the
last filter delegates to the <code>DispatcherServlet</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-vs-end-to-end-integration-tests"><a class="anchor" href="#spring-mvc-test-vs-end-to-end-integration-tests"></a>Spring MVC Test vs End-to-End Tests</h5>
<div class="paragraph">
<p>Spring MVC Test is built on Servlet API mock implementations from the
<code>spring-test</code> module and does not rely on a running container. Therefore, there are
some differences when compared to full end-to-end integration tests with an actual
client and a live server running.</p>
</div>
<div class="paragraph">
<p>The easiest way to think about this is by starting with a blank <code>MockHttpServletRequest</code>.
Whatever you add to it is what the request becomes. Things that may catch you by surprise
are that there is no context path by default; no <code>jsessionid</code> cookie; no forwarding,
error, or async dispatches; and, therefore, no actual JSP rendering. Instead,
&#8220;forwarded&#8221; and &#8220;redirected&#8221; URLs are saved in the <code>MockHttpServletResponse</code> and can
be asserted with expectations.</p>
</div>
<div class="paragraph">
<p>This means that, if you use JSPs, you can verify the JSP page to which the request was
forwarded, but no HTML is rendered. In other words, the JSP is not invoked. Note,
however, that all other rendering technologies that do not rely on forwarding, such as
Thymeleaf and Freemarker, render HTML to the response body as expected. The same is true
for rendering JSON, XML, and other formats through <code>@ResponseBody</code> methods.</p>
</div>
<div class="paragraph">
<p>Alternatively, you may consider the full end-to-end integration testing support from
Spring Boot with <code>@SpringBootTest</code>. See the
<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing">Spring Boot Reference Guide</a>.</p>
</div>
<div class="paragraph">
<p>There are pros and cons for each approach. The options provided in Spring MVC Test are
different stops on the scale from classic unit testing to full integration testing. To be
certain, none of the options in Spring MVC Test fall under the category of classic unit
testing, but they are a little closer to it. For example, you can isolate the web layer
by injecting mocked services into controllers, in which case you are testing the web
layer only through the <code>DispatcherServlet</code> but with actual Spring configuration, as you
might test the data access layer in isolation from the layers above it. Also, you can use
the stand-alone setup, focusing on one controller at a time and manually providing the
configuration required to make it work.</p>
</div>
<div class="paragraph">
<p>Another important distinction when using Spring MVC Test is that, conceptually, such
tests are the server-side, so you can check what handler was used, if an exception was
handled with a HandlerExceptionResolver, what the content of the model is, what binding
errors there were, and other details. That means that it is easier to write expectations,
since the server is not a black box, as it is when testing it through an actual HTTP
client. This is generally an advantage of classic unit testing: It is easier to write,
reason about, and debug but does not replace the need for full integration tests. At the
same time, it is important not to lose sight of the fact that the response is the most
important thing to check. In short, there is room here for multiple styles and strategies
of testing even within the same project.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-resources"><a class="anchor" href="#spring-mvc-test-server-resources"></a>Further Examples</h5>
<div class="paragraph">
<p>The framework&#8217;s own tests include
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples">many
sample tests</a> intended to show how to use Spring MVC Test. You can browse these examples
for further ideas. Also, the
<a href="https://github.com/spring-projects/spring-mvc-showcase"><code>spring-mvc-showcase</code></a> project has
full test coverage based on Spring MVC Test.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-mvc-test-server-htmlunit"><a class="anchor" href="#spring-mvc-test-server-htmlunit"></a>3.6.2. HtmlUnit Integration</h4>
<div class="paragraph">
<p>Spring provides integration between <a href="#spring-mvc-test-server">MockMvc</a> and
<a href="http://htmlunit.sourceforge.net/">HtmlUnit</a>. This simplifies performing end-to-end testing
when using HTML-based views. This integration lets you:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Easily test HTML pages by using tools such as
<a href="http://htmlunit.sourceforge.net/">HtmlUnit</a>,
<a href="https://www.seleniumhq.org">WebDriver</a>, and
<a href="http://www.gebish.org/manual/current/#spock-junit-testng">Geb</a> without the need to
deploy to a Servlet container.</p>
</li>
<li>
<p>Test JavaScript within pages.</p>
</li>
<li>
<p>Optionally, test using mock services to speed up testing.</p>
</li>
<li>
<p>Share logic between in-container end-to-end tests and out-of-container integration tests.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
MockMvc works with templating technologies that do not rely on a Servlet Container
(for example, Thymeleaf, FreeMarker, and others), but it does not work with JSPs, since
they rely on the Servlet container.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-why"><a class="anchor" href="#spring-mvc-test-server-htmlunit-why"></a>Why HtmlUnit Integration?</h5>
<div class="paragraph">
<p>The most obvious question that comes to mind is &#8220;Why do I need this?&#8221; The answer is
best found by exploring a very basic sample application. Assume you have a Spring MVC web
application that supports CRUD operations on a <code>Message</code> object. The application also
supports paging through all messages. How would you go about testing it?</p>
</div>
<div class="paragraph">
<p>With Spring MVC Test, we can easily test if we are able to create a <code>Message</code>, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MockHttpServletRequestBuilder createMessage = post("/messages/")
        .param("summary", "Spring Rocks")
        .param("text", "In case you didn't know, Spring Rocks!");

mockMvc.perform(createMessage)
        .andExpect(status().is3xxRedirection())
        .andExpect(redirectedUrl("/messages/123"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Test
fun test() {
    mockMvc.post("/messages/") {
        param("summary", "Spring Rocks")
        param("text", "In case you didn't know, Spring Rocks!")
    }.andExpect {
        status().is3xxRedirection()
        redirectedUrl("/messages/123")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What if we want to test the form view that lets us create the message? For example,
assume our form looks like the following snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;form id="messageForm" action="/messages/" method="post"&gt;
    &lt;div class="pull-right"&gt;&lt;a href="/messages/"&gt;Messages&lt;/a&gt;&lt;/div&gt;

    &lt;label for="summary"&gt;Summary&lt;/label&gt;
    &lt;input type="text" class="required" id="summary" name="summary" value="" /&gt;

    &lt;label for="text"&gt;Message&lt;/label&gt;
    &lt;textarea id="text" name="text"&gt;&lt;/textarea&gt;

    &lt;div class="form-actions"&gt;
        &lt;input type="submit" value="Create" /&gt;
    &lt;/div&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>How do we ensure that our form produce the correct request to create a new message? A
naive attempt might resemble the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mockMvc.perform(get("/messages/form"))
        .andExpect(xpath("//input[@name='summary']").exists())
        .andExpect(xpath("//textarea[@name='text']").exists());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">mockMvc.get("/messages/form").andExpect {
    xpath("//input[@name='summary']") { exists() }
    xpath("//textarea[@name='text']") { exists() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This test has some obvious drawbacks. If we update our controller to use the parameter
<code>message</code> instead of <code>text</code>, our form test continues to pass, even though the HTML form
is out of synch with the controller. To resolve this we can combine our two tests, as
follows:</p>
</div>
<div id="spring-mvc-test-server-htmlunit-mock-mvc-test" class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String summaryParamName = "summary";
String textParamName = "text";
mockMvc.perform(get("/messages/form"))
        .andExpect(xpath("//input[@name='" + summaryParamName + "']").exists())
        .andExpect(xpath("//textarea[@name='" + textParamName + "']").exists());

MockHttpServletRequestBuilder createMessage = post("/messages/")
        .param(summaryParamName, "Spring Rocks")
        .param(textParamName, "In case you didn't know, Spring Rocks!");

mockMvc.perform(createMessage)
        .andExpect(status().is3xxRedirection())
        .andExpect(redirectedUrl("/messages/123"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val summaryParamName = "summary";
val textParamName = "text";
mockMvc.get("/messages/form").andExpect {
    xpath("//input[@name='$summaryParamName']") { exists() }
    xpath("//textarea[@name='$textParamName']") { exists() }
}
mockMvc.post("/messages/") {
    param(summaryParamName, "Spring Rocks")
    param(textParamName, "In case you didn't know, Spring Rocks!")
}.andExpect {
    status().is3xxRedirection()
    redirectedUrl("/messages/123")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This would reduce the risk of our test incorrectly passing, but there are still some
problems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>What if we have multiple forms on our page? Admittedly, we could update our XPath
expressions, but they get more complicated as we take more factors into account: Are
the fields the correct type? Are the fields enabled? And so on.</p>
</li>
<li>
<p>Another issue is that we are doing double the work we would expect. We must first
verify the view, and then we submit the view with the same parameters we just verified.
Ideally, this could be done all at once.</p>
</li>
<li>
<p>Finally, we still cannot account for some things. For example, what if the form has
JavaScript validation that we wish to test as well?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The overall problem is that testing a web page does not involve a single interaction.
Instead, it is a combination of how the user interacts with a web page and how that web
page interacts with other resources. For example, the result of a form view is used as
the input to a user for creating a message. In addition, our form view can potentially
use additional resources that impact the behavior of the page, such as JavaScript
validation.</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-why-integration"><a class="anchor" href="#spring-mvc-test-server-htmlunit-why-integration"></a>Integration Testing to the Rescue?</h6>
<div class="paragraph">
<p>To resolve the issues mentioned earlier, we could perform end-to-end integration testing,
but this has some drawbacks. Consider testing the view that lets us page through the
messages. We might need the following tests:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Does our page display a notification to the user to indicate that no results are
available when the messages are empty?</p>
</li>
<li>
<p>Does our page properly display a single message?</p>
</li>
<li>
<p>Does our page properly support paging?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To set up these tests, we need to ensure our database contains the proper messages. This
leads to a number of additional challenges:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensuring the proper messages are in the database can be tedious. (Consider foreign key
constraints.)</p>
</li>
<li>
<p>Testing can become slow, since each test would need to ensure that the database is in
the correct state.</p>
</li>
<li>
<p>Since our database needs to be in a specific state, we cannot run tests in parallel.</p>
</li>
<li>
<p>Performing assertions on such items as auto-generated ids, timestamps, and others can
be difficult.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These challenges do not mean that we should abandon end-to-end integration testing
altogether. Instead, we can reduce the number of end-to-end integration tests by
refactoring our detailed tests to use mock services that run much faster, more reliably,
and without side effects. We can then implement a small number of true end-to-end
integration tests that validate simple workflows to ensure that everything works together
properly.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-why-mockmvc"><a class="anchor" href="#spring-mvc-test-server-htmlunit-why-mockmvc"></a>Enter HtmlUnit Integration</h6>
<div class="paragraph">
<p>So how can we achieve a balance between testing the interactions of our pages and still
retain good performance within our test suite? The answer is: &#8220;By integrating MockMvc
with HtmlUnit.&#8221;</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-options"><a class="anchor" href="#spring-mvc-test-server-htmlunit-options"></a>HtmlUnit Integration Options</h6>
<div class="paragraph">
<p>You have a number of options when you want to integrate MockMvc with HtmlUnit:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-mvc-test-server-htmlunit-mah">MockMvc and HtmlUnit</a>: Use this option if you
want to use the raw HtmlUnit libraries.</p>
</li>
<li>
<p><a href="#spring-mvc-test-server-htmlunit-webdriver">MockMvc and WebDriver</a>: Use this option to
ease development and reuse code between integration and end-to-end testing.</p>
</li>
<li>
<p><a href="#spring-mvc-test-server-htmlunit-geb">MockMvc and Geb</a>: Use this option if you want to
use Groovy for testing, ease development, and reuse code between integration and
end-to-end testing.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-mah"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah"></a>MockMvc and HtmlUnit</h5>
<div class="paragraph">
<p>This section describes how to integrate MockMvc and HtmlUnit. Use this option if you want
to use the raw HtmlUnit libraries.</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-mah-setup"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah-setup"></a>MockMvc and HtmlUnit Setup</h6>
<div class="paragraph">
<p>First, make sure that you have included a test dependency on
<code>net.sourceforge.htmlunit:htmlunit</code>. In order to use HtmlUnit with Apache HttpComponents
4.5+, you need to use HtmlUnit 2.18 or higher.</p>
</div>
<div class="paragraph">
<p>We can easily create an HtmlUnit <code>WebClient</code> that integrates with MockMvc by using the
<code>MockMvcWebClientBuilder</code>, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WebClient webClient;

@BeforeEach
void setup(WebApplicationContext context) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">lateinit var webClient: WebClient

@BeforeEach
fun setup(context: WebApplicationContext) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is a simple example of using <code>MockMvcWebClientBuilder</code>. For advanced usage,
see <a href="#spring-mvc-test-server-htmlunit-mah-advanced-builder">Advanced <code>MockMvcWebClientBuilder</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This ensures that any URL that references <code>localhost</code> as the server is directed to our
<code>MockMvc</code> instance without the need for a real HTTP connection. Any other URL is
requested by using a network connection, as normal. This lets us easily test the use of
CDNs.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-mah-usage"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah-usage"></a>MockMvc and HtmlUnit Usage</h6>
<div class="paragraph">
<p>Now we can use HtmlUnit as we normally would but without the need to deploy our
application to a Servlet container. For example, we can request the view to create a
message with the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HtmlPage createMsgFormPage = webClient.getPage("http://localhost/messages/form");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val createMsgFormPage = webClient.getPage("http://localhost/messages/form")</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default context path is <code>""</code>. Alternatively, we can specify the context path,
as described in <a href="#spring-mvc-test-server-htmlunit-mah-advanced-builder">Advanced <code>MockMvcWebClientBuilder</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once we have a reference to the <code>HtmlPage</code>, we can then fill out the form and submit it
to create a message, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HtmlForm form = createMsgFormPage.getHtmlElementById("messageForm");
HtmlTextInput summaryInput = createMsgFormPage.getHtmlElementById("summary");
summaryInput.setValueAttribute("Spring Rocks");
HtmlTextArea textInput = createMsgFormPage.getHtmlElementById("text");
textInput.setText("In case you didn't know, Spring Rocks!");
HtmlSubmitInput submit = form.getOneHtmlElementByAttribute("input", "type", "submit");
HtmlPage newMessagePage = submit.click();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val form = createMsgFormPage.getHtmlElementById("messageForm")
val summaryInput = createMsgFormPage.getHtmlElementById("summary")
summaryInput.setValueAttribute("Spring Rocks")
val textInput = createMsgFormPage.getHtmlElementById("text")
textInput.setText("In case you didn't know, Spring Rocks!")
val submit = form.getOneHtmlElementByAttribute("input", "type", "submit")
val newMessagePage = submit.click()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we can verify that a new message was created successfully. The following
assertions use the <a href="https://joel-costigliola.github.io/assertj/">AssertJ</a> library:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(newMessagePage.getUrl().toString()).endsWith("/messages/123");
String id = newMessagePage.getHtmlElementById("id").getTextContent();
assertThat(id).isEqualTo("123");
String summary = newMessagePage.getHtmlElementById("summary").getTextContent();
assertThat(summary).isEqualTo("Spring Rocks");
String text = newMessagePage.getHtmlElementById("text").getTextContent();
assertThat(text).isEqualTo("In case you didn't know, Spring Rocks!");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">assertThat(newMessagePage.getUrl().toString()).endsWith("/messages/123")
val id = newMessagePage.getHtmlElementById("id").getTextContent()
assertThat(id).isEqualTo("123")
val summary = newMessagePage.getHtmlElementById("summary").getTextContent()
assertThat(summary).isEqualTo("Spring Rocks")
val text = newMessagePage.getHtmlElementById("text").getTextContent()
assertThat(text).isEqualTo("In case you didn't know, Spring Rocks!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding code improves on our
<a href="#spring-mvc-test-server-htmlunit-mock-mvc-test">MockMvc test</a> in a number of ways.
First, we no longer have to explicitly verify our form and then create a request that
looks like the form. Instead, we request the form, fill it out, and submit it, thereby
significantly reducing the overhead.</p>
</div>
<div class="paragraph">
<p>Another important factor is that <a href="http://htmlunit.sourceforge.net/javascript.html">HtmlUnit
uses the Mozilla Rhino engine</a> to evaluate JavaScript. This means that we can also test
the behavior of JavaScript within our pages.</p>
</div>
<div class="paragraph">
<p>See the <a href="http://htmlunit.sourceforge.net/gettingStarted.html">HtmlUnit documentation</a> for
additional information about using HtmlUnit.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-mah-advanced-builder"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah-advanced-builder"></a>Advanced <code>MockMvcWebClientBuilder</code></h6>
<div class="paragraph">
<p>In the examples so far, we have used <code>MockMvcWebClientBuilder</code> in the simplest way
possible, by building a <code>WebClient</code> based on the <code>WebApplicationContext</code> loaded for us by
the Spring TestContext Framework. This approach is repeated in the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WebClient webClient;

@BeforeEach
void setup(WebApplicationContext context) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">lateinit var webClient: WebClient

@BeforeEach
fun setup(context: WebApplicationContext) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also specify additional configuration options, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WebClient webClient;

@BeforeEach
void setup() {
    webClient = MockMvcWebClientBuilder
        // demonstrates applying a MockMvcConfigurer (Spring Security)
        .webAppContextSetup(context, springSecurity())
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">lateinit var webClient: WebClient

@BeforeEach
fun setup() {
    webClient = MockMvcWebClientBuilder
        // demonstrates applying a MockMvcConfigurer (Spring Security)
        .webAppContextSetup(context, springSecurity())
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As an alternative, we can perform the exact same setup by configuring the <code>MockMvc</code>
instance separately and supplying it to the <code>MockMvcWebClientBuilder</code>, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MockMvc mockMvc = MockMvcBuilders
        .webAppContextSetup(context)
        .apply(springSecurity())
        .build();

webClient = MockMvcWebClientBuilder
        .mockMvcSetup(mockMvc)
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is more verbose, but, by building the <code>WebClient</code> with a <code>MockMvc</code> instance, we have
the full power of MockMvc at our fingertips.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For additional information on creating a <code>MockMvc</code> instance, see
<a href="#spring-mvc-test-server-setup-options">Setup Choices</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-webdriver"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver"></a>MockMvc and WebDriver</h5>
<div class="paragraph">
<p>In the previous sections, we have seen how to use MockMvc in conjunction with the raw
HtmlUnit APIs. In this section, we use additional abstractions within the Selenium
<a href="https://docs.seleniumhq.org/projects/webdriver/">WebDriver</a> to make things even easier.</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-why"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-why"></a>Why WebDriver and MockMvc?</h6>
<div class="paragraph">
<p>We can already use HtmlUnit and MockMvc, so why would we want to use WebDriver? The
Selenium WebDriver provides a very elegant API that lets us easily organize our code. To
better show how it works, we explore an example in this section.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Despite being a part of <a href="https://docs.seleniumhq.org/">Selenium</a>, WebDriver does not
require a Selenium Server to run your tests.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Suppose we need to ensure that a message is created properly. The tests involve finding
the HTML form input elements, filling them out, and making various assertions.</p>
</div>
<div class="paragraph">
<p>This approach results in numerous separate tests because we want to test error conditions
as well. For example, we want to ensure that we get an error if we fill out only part of
the form. If we fill out the entire form, the newly created message should be displayed
afterwards.</p>
</div>
<div class="paragraph">
<p>If one of the fields were named &#8220;summary&#8221;, we might have something that resembles the
following repeated in multiple places within our tests:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HtmlTextInput summaryInput = currentPage.getHtmlElementById("summary");
summaryInput.setValueAttribute(summary);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val summaryInput = currentPage.getHtmlElementById("summary")
summaryInput.setValueAttribute(summary)</code></pre>
</div>
</div>
<div class="paragraph">
<p>So what happens if we change the <code>id</code> to <code>smmry</code>? Doing so would force us to update all
of our tests to incorporate this change. This violates the DRY principle, so we should
ideally extract this code into its own method, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public HtmlPage createMessage(HtmlPage currentPage, String summary, String text) {
    setSummary(currentPage, summary);
    // ...
}

public void setSummary(HtmlPage currentPage, String summary) {
    HtmlTextInput summaryInput = currentPage.getHtmlElementById("summary");
    summaryInput.setValueAttribute(summary);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun createMessage(currentPage: HtmlPage, summary:String, text:String) :HtmlPage{
    setSummary(currentPage, summary);
    // ...
}

fun setSummary(currentPage:HtmlPage , summary: String) {
    val summaryInput = currentPage.getHtmlElementById("summary")
    summaryInput.setValueAttribute(summary)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Doing so ensures that we do not have to update all of our tests if we change the UI.</p>
</div>
<div class="paragraph">
<p>We might even take this a step further and place this logic within an <code>Object</code> that
represents the <code>HtmlPage</code> we are currently on, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CreateMessagePage {

    final HtmlPage currentPage;

    final HtmlTextInput summaryInput;

    final HtmlSubmitInput submit;

    public CreateMessagePage(HtmlPage currentPage) {
        this.currentPage = currentPage;
        this.summaryInput = currentPage.getHtmlElementById("summary");
        this.submit = currentPage.getHtmlElementById("submit");
    }

    public &lt;T&gt; T createMessage(String summary, String text) throws Exception {
        setSummary(summary);

        HtmlPage result = submit.click();
        boolean error = CreateMessagePage.at(result);

        return (T) (error ? new CreateMessagePage(result) : new ViewMessagePage(result));
    }

    public void setSummary(String summary) throws Exception {
        summaryInput.setValueAttribute(summary);
    }

    public static boolean at(HtmlPage page) {
        return "Create Message".equals(page.getTitleText());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">    class CreateMessagePage(private val currentPage: HtmlPage) {

        val summaryInput: HtmlTextInput = currentPage.getHtmlElementById("summary")

        val submit: HtmlSubmitInput = currentPage.getHtmlElementById("submit")

        fun &lt;T&gt; createMessage(summary: String, text: String): T {
            setSummary(summary)

            val result = submit.click()
            val error = at(result)

            return (if (error) CreateMessagePage(result) else ViewMessagePage(result)) as T
        }

        fun setSummary(summary: String) {
            summaryInput.setValueAttribute(summary)
        }

        fun at(page: HtmlPage): Boolean {
            return "Create Message" == page.getTitleText()
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Formerly, this pattern was known as the
<a href="https://github.com/SeleniumHQ/selenium/wiki/PageObjects">Page Object Pattern</a>. While we
can certainly do this with HtmlUnit, WebDriver provides some tools that we explore in the
following sections to make this pattern much easier to implement.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-setup"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-setup"></a>MockMvc and WebDriver Setup</h6>
<div class="paragraph">
<p>To use Selenium WebDriver with the Spring MVC Test framework, make sure that your project
includes a test dependency on <code>org.seleniumhq.selenium:selenium-htmlunit-driver</code>.</p>
</div>
<div class="paragraph">
<p>We can easily create a Selenium WebDriver that integrates with MockMvc by using the
<code>MockMvcHtmlUnitDriverBuilder</code> as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WebDriver driver;

@BeforeEach
void setup(WebApplicationContext context) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">lateinit var driver: WebDriver

@BeforeEach
fun setup(context: WebApplicationContext) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is a simple example of using <code>MockMvcHtmlUnitDriverBuilder</code>. For more advanced
usage, see <a href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder">Advanced <code>MockMvcHtmlUnitDriverBuilder</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The preceding example ensures that any URL that references <code>localhost</code> as the server is
directed to our <code>MockMvc</code> instance without the need for a real HTTP connection. Any other
URL is requested by using a network connection, as normal. This lets us easily test the
use of CDNs.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-usage"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-usage"></a>MockMvc and WebDriver Usage</h6>
<div class="paragraph">
<p>Now we can use WebDriver as we normally would but without the need to deploy our
application to a Servlet container. For example, we can request the view to create a
message with the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CreateMessagePage page = CreateMessagePage.to(driver);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val page = CreateMessagePage.to(driver)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can then fill out the form and submit it to create a message, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ViewMessagePage viewMessagePage =
        page.createMessage(ViewMessagePage.class, expectedSummary, expectedText);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val viewMessagePage =
    page.createMessage(ViewMessagePage::class, expectedSummary, expectedText)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This improves on the design of our <a href="#spring-mvc-test-server-htmlunit-mah-usage">HtmlUnit test</a>
by leveraging the Page Object Pattern. As we mentioned in
<a href="#spring-mvc-test-server-htmlunit-webdriver-why">Why WebDriver and MockMvc?</a>, we can use the Page Object Pattern
with HtmlUnit, but it is much easier with WebDriver. Consider the following
<code>CreateMessagePage</code> implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CreateMessagePage
        extends AbstractPage { <i class="conum" data-value="1"></i><b>(1)</b>

    <i class="conum" data-value="2"></i><b>(2)</b>
    private WebElement summary;
    private WebElement text;

    <i class="conum" data-value="3"></i><b>(3)</b>
    @FindBy(css = "input[type=submit]")
    private WebElement submit;

    public CreateMessagePage(WebDriver driver) {
        super(driver);
    }

    public &lt;T&gt; T createMessage(Class&lt;T&gt; resultPage, String summary, String details) {
        this.summary.sendKeys(summary);
        this.text.sendKeys(details);
        this.submit.click();
        return PageFactory.initElements(driver, resultPage);
    }

    public static CreateMessagePage to(WebDriver driver) {
        driver.get("http://localhost:9990/mail/messages/form");
        return PageFactory.initElements(driver, CreateMessagePage.class);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>CreateMessagePage</code> extends the <code>AbstractPage</code>. We do not go over the details of
<code>AbstractPage</code>, but, in summary, it contains common functionality for all of our pages.
For example, if our application has a navigational bar, global error messages, and other
features, we can place this logic in a shared location.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We have a member variable for each of the parts of the HTML page in which we are
interested. These are of type <code>WebElement</code>. WebDriver&#8217;s
<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory"><code>PageFactory</code></a> lets us remove a
lot of code from the HtmlUnit version of <code>CreateMessagePage</code> by automatically resolving
each <code>WebElement</code>. The
<a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-"><code>PageFactory#initElements(WebDriver,Class&lt;T&gt;)</code></a>
method automatically resolves each <code>WebElement</code> by using the field name and looking it up
by the <code>id</code> or <code>name</code> of the element within the HTML page.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We can use the
<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations"><code>@FindBy</code> annotation</a>
to override the default lookup behavior. Our example shows how to use the <code>@FindBy</code>
annotation to look up our submit button with a <code>css</code> selector (<strong>input[type=submit]</strong>).</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class CreateMessagePage(private val driver: WebDriver) : AbstractPage(driver) { <i class="conum" data-value="1"></i><b>(1)</b>

    <i class="conum" data-value="2"></i><b>(2)</b>
    private lateinit var summary: WebElement
    private lateinit var text: WebElement

    <i class="conum" data-value="3"></i><b>(3)</b>
    @FindBy(css = "input[type=submit]")
    private lateinit var submit: WebElement

    fun &lt;T&gt; createMessage(resultPage: Class&lt;T&gt;, summary: String, details: String): T {
        this.summary.sendKeys(summary)
        text.sendKeys(details)
        submit.click()
        return PageFactory.initElements(driver, resultPage)
    }
    companion object {
        fun to(driver: WebDriver): CreateMessagePage {
            driver.get("http://localhost:9990/mail/messages/form")
            return PageFactory.initElements(driver, CreateMessagePage::class.java)
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>CreateMessagePage</code> extends the <code>AbstractPage</code>. We do not go over the details of
<code>AbstractPage</code>, but, in summary, it contains common functionality for all of our pages.
For example, if our application has a navigational bar, global error messages, and other
features, we can place this logic in a shared location.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We have a member variable for each of the parts of the HTML page in which we are
interested. These are of type <code>WebElement</code>. WebDriver&#8217;s
<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory"><code>PageFactory</code></a> lets us remove a
lot of code from the HtmlUnit version of <code>CreateMessagePage</code> by automatically resolving
each <code>WebElement</code>. The
<a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-"><code>PageFactory#initElements(WebDriver,Class&lt;T&gt;)</code></a>
method automatically resolves each <code>WebElement</code> by using the field name and looking it up
by the <code>id</code> or <code>name</code> of the element within the HTML page.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We can use the
<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations"><code>@FindBy</code> annotation</a>
to override the default lookup behavior. Our example shows how to use the <code>@FindBy</code>
annotation to look up our submit button with a <code>css</code> selector (<strong>input[type=submit]</strong>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, we can verify that a new message was created successfully. The following
assertions use the <a href="https://joel-costigliola.github.io/assertj/">AssertJ</a> assertion library:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(viewMessagePage.getMessage()).isEqualTo(expectedMessage);
assertThat(viewMessagePage.getSuccess()).isEqualTo("Successfully created a new message");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">assertThat(viewMessagePage.message.isEqualTo(expectedMessage)
assertThat(viewMessagePage.success.isEqualTo("Successfully created a new message")</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can see that our <code>ViewMessagePage</code> lets us interact with our custom domain model. For
example, it exposes a method that returns a <code>Message</code> object:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Message getMessage() throws ParseException {
    Message message = new Message();
    message.setId(getId());
    message.setCreated(getCreated());
    message.setSummary(getSummary());
    message.setText(getText());
    return message;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">fun getMessage() = Message(getId(), getCreated(), getSummary(), getText())</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can then use the rich domain objects in our assertions.</p>
</div>
<div class="paragraph">
<p>Lastly, we must not forget to close the <code>WebDriver</code> instance when the test is complete,
as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AfterEach
void destroy() {
    if (driver != null) {
        driver.close();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@AfterEach
fun destroy() {
    if (driver != null) {
        driver.close()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For additional information on using WebDriver, see the Selenium
<a href="https://github.com/SeleniumHQ/selenium/wiki/Getting-Started">WebDriver documentation</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-advanced-builder"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder"></a>Advanced <code>MockMvcHtmlUnitDriverBuilder</code></h6>
<div class="paragraph">
<p>In the examples so far, we have used <code>MockMvcHtmlUnitDriverBuilder</code> in the simplest way
possible, by building a <code>WebDriver</code> based on the <code>WebApplicationContext</code> loaded for us by
the Spring TestContext Framework. This approach is repeated here, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WebDriver driver;

@BeforeEach
void setup(WebApplicationContext context) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">lateinit var driver: WebDriver

@BeforeEach
fun setup(context: WebApplicationContext) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also specify additional configuration options, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WebDriver driver;

@BeforeEach
void setup() {
    driver = MockMvcHtmlUnitDriverBuilder
            // demonstrates applying a MockMvcConfigurer (Spring Security)
            .webAppContextSetup(context, springSecurity())
            // for illustration only - defaults to ""
            .contextPath("")
            // By default MockMvc is used for localhost only;
            // the following will use MockMvc for example.com and example.org as well
            .useMockMvcForHosts("example.com","example.org")
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">lateinit var driver: WebDriver

@BeforeEach
fun setup() {
    driver = MockMvcHtmlUnitDriverBuilder
            // demonstrates applying a MockMvcConfigurer (Spring Security)
            .webAppContextSetup(context, springSecurity())
            // for illustration only - defaults to ""
            .contextPath("")
            // By default MockMvc is used for localhost only;
            // the following will use MockMvc for example.com and example.org as well
            .useMockMvcForHosts("example.com","example.org")
            .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As an alternative, we can perform the exact same setup by configuring the <code>MockMvc</code>
instance separately and supplying it to the <code>MockMvcHtmlUnitDriverBuilder</code>, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MockMvc mockMvc = MockMvcBuilders
        .webAppContextSetup(context)
        .apply(springSecurity())
        .build();

driver = MockMvcHtmlUnitDriverBuilder
        .mockMvcSetup(mockMvc)
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is more verbose, but, by building the <code>WebDriver</code> with a <code>MockMvc</code> instance, we have
the full power of MockMvc at our fingertips.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For additional information on creating a <code>MockMvc</code> instance, see
<a href="#spring-mvc-test-server-setup-options">Setup Choices</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-geb"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb"></a>MockMvc and Geb</h5>
<div class="paragraph">
<p>In the previous section, we saw how to use MockMvc with WebDriver. In this section, we
use <a href="http://www.gebish.org/">Geb</a> to make our tests even Groovy-er.</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-geb-why"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb-why"></a>Why Geb and MockMvc?</h6>
<div class="paragraph">
<p>Geb is backed by WebDriver, so it offers many of the
<a href="#spring-mvc-test-server-htmlunit-webdriver-why">same benefits</a> that we get from
WebDriver. However, Geb makes things even easier by taking care of some of the
boilerplate code for us.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-geb-setup"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb-setup"></a>MockMvc and Geb Setup</h6>
<div class="paragraph">
<p>We can easily initialize a Geb <code>Browser</code> with a Selenium WebDriver that uses MockMvc, as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">def setup() {
    browser.driver = MockMvcHtmlUnitDriverBuilder
        .webAppContextSetup(context)
        .build()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is a simple example of using <code>MockMvcHtmlUnitDriverBuilder</code>. For more advanced
usage, see <a href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder">Advanced <code>MockMvcHtmlUnitDriverBuilder</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This ensures that any URL referencing <code>localhost</code> as the server is directed to our
<code>MockMvc</code> instance without the need for a real HTTP connection. Any other URL is
requested by using a network connection as normal. This lets us easily test the use of
CDNs.</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-geb-usage"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb-usage"></a>MockMvc and Geb Usage</h6>
<div class="paragraph">
<p>Now we can use Geb as we normally would but without the need to deploy our application to
a Servlet container. For example, we can request the view to create a message with the
following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">to CreateMessagePage</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can then fill out the form and submit it to create a message, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">when:
form.summary = expectedSummary
form.text = expectedMessage
submit.click(ViewMessagePage)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any unrecognized method calls or property accesses or references that are not found are
forwarded to the current page object. This removes a lot of the boilerplate code we
needed when using WebDriver directly.</p>
</div>
<div class="paragraph">
<p>As with direct WebDriver usage, this improves on the design of our
<a href="#spring-mvc-test-server-htmlunit-mah-usage">HtmlUnit test</a> by using the Page Object
Pattern. As mentioned previously, we can use the Page Object Pattern with HtmlUnit and
WebDriver, but it is even easier with Geb. Consider our new Groovy-based
<code>CreateMessagePage</code> implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">class CreateMessagePage extends Page {
    static url = 'messages/form'
    static at = { assert title == 'Messages : Create'; true }
    static content =  {
        submit { $('input[type=submit]') }
        form { $('form') }
        errors(required:false) { $('label.error, .alert-error')?.text() }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our <code>CreateMessagePage</code> extends <code>Page</code>. We do not go over the details of <code>Page</code>, but, in
summary, it contains common functionality for all of our pages. We define a URL in which
this page can be found. This lets us navigate to the page, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">to CreateMessagePage</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also have an <code>at</code> closure that determines if we are at the specified page. It should
return <code>true</code> if we are on the correct page. This is why we can assert that we are on the
correct page, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">then:
at CreateMessagePage
errors.contains('This field is required.')</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We use an assertion in the closure so that we can determine where things went wrong
if we were at the wrong page.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next, we create a <code>content</code> closure that specifies all the areas of interest within the
page. We can use a
<a href="http://www.gebish.org/manual/current/#the-jquery-ish-navigator-api">jQuery-ish Navigator
API</a> to select the content in which we are interested.</p>
</div>
<div class="paragraph">
<p>Finally, we can verify that a new message was created successfully, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">then:
at ViewMessagePage
success == 'Successfully created a new message'
id
date
summary == expectedSummary
message == expectedMessage</code></pre>
</div>
</div>
<div class="paragraph">
<p>For further details on how to get the most out of Geb, see
<a href="http://www.gebish.org/manual/current/">The Book of Geb</a> user&#8217;s manual.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-mvc-test-client"><a class="anchor" href="#spring-mvc-test-client"></a>3.6.3. Client-Side REST Tests</h4>
<div class="paragraph">
<p>You can use client-side tests to test code that internally uses the <code>RestTemplate</code>. The
idea is to declare expected requests and to provide &#8220;stub&#8221; responses so that you can
focus on testing the code in isolation (that is, without running a server). The following
example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(requestTo("/greeting")).andRespond(withSuccess());

// Test code that uses the above RestTemplate ...

mockServer.verify();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val restTemplate = RestTemplate()

val mockServer = MockRestServiceServer.bindTo(restTemplate).build()
mockServer.expect(requestTo("/greeting")).andRespond(withSuccess())

// Test code that uses the above RestTemplate ...

mockServer.verify()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, <code>MockRestServiceServer</code> (the central class for client-side REST
tests) configures the <code>RestTemplate</code> with a custom <code>ClientHttpRequestFactory</code> that
asserts actual requests against expectations and returns &#8220;stub&#8221; responses. In this
case, we expect a request to <code>/greeting</code> and want to return a 200 response with
<code>text/plain</code> content. We can define additional expected requests and stub responses as
needed. When we define expected requests and stub responses, the <code>RestTemplate</code> can be
used in client-side code as usual. At the end of testing, <code>mockServer.verify()</code> can be
used to verify that all expectations have been satisfied.</p>
</div>
<div class="paragraph">
<p>By default, requests are expected in the order in which expectations were declared. You
can set the <code>ignoreExpectOrder</code> option when building the server, in which case all
expectations are checked (in order) to find a match for a given request. That means
requests are allowed to come in any order. The following example uses <code>ignoreExpectOrder</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even with unordered requests by default, each request is allowed to execute once only.
The <code>expect</code> method provides an overloaded variant that accepts an <code>ExpectedCount</code>
argument that specifies a count range (for example, <code>once</code>, <code>manyTimes</code>, <code>max</code>, <code>min</code>,
<code>between</code>, and so on). The following example uses <code>times</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RestTemplate restTemplate = new RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess());
mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess());

// ...

mockServer.verify();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val restTemplate = RestTemplate()

val mockServer = MockRestServiceServer.bindTo(restTemplate).build()
mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess())
mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess())

// ...

mockServer.verify()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that, when <code>ignoreExpectOrder</code> is not set (the default), and, therefore, requests
are expected in order of declaration, then that order applies only to the first of any
expected request. For example if "/something" is expected two times followed by
"/somewhere" three times, then there should be a request to "/something" before there is
a request to "/somewhere", but, aside from that subsequent "/something" and "/somewhere",
requests can come at any time.</p>
</div>
<div class="paragraph">
<p>As an alternative to all of the above, the client-side test support also provides a
<code>ClientHttpRequestFactory</code> implementation that you can configure into a <code>RestTemplate</code> to
bind it to a <code>MockMvc</code> instance. That allows processing requests using actual server-side
logic but without running a server. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
this.restTemplate = new RestTemplate(new MockMvcClientHttpRequestFactory(mockMvc));

// Test code that uses the above RestTemplate ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build()
restTemplate = RestTemplate(MockMvcClientHttpRequestFactory(mockMvc))

// Test code that uses the above RestTemplate ...</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-client-static-imports"><a class="anchor" href="#spring-mvc-test-client-static-imports"></a>Static Imports</h5>
<div class="paragraph">
<p>As with server-side tests, the fluent API for client-side tests requires a few static
imports. Those are easy to find by searching for <code>MockRest*</code>. Eclipse users should add
<code>MockRestRequestMatchers.*</code> and <code>MockRestResponseCreators.*</code> as
&#8220;favorite static members&#8221; in the Eclipse preferences under Java &#8594; Editor &#8594; Content
Assist &#8594; Favorites. That allows using content assist after typing the first character of
the static method name. Other IDEs (such IntelliJ) may not require any additional
configuration. Check for the support for code completion on static members.</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-client-resources"><a class="anchor" href="#spring-mvc-test-client-resources"></a>Further Examples of Client-side REST Tests</h5>
<div class="paragraph">
<p>Spring MVC Test&#8217;s own tests include
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/client/samples">example
tests</a> of client-side REST tests.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient"><a class="anchor" href="#webtestclient"></a>3.7. WebTestClient</h3>
<div class="paragraph">
<p><code>WebTestClient</code> is a thin shell around <a href="web-reactive.html#webflux-client">WebClient</a>,
using it to perform requests and exposing a dedicated, fluent API for verifying responses.
<code>WebTestClient</code> binds to a WebFlux application by using a
<a href="#mock-objects-web-reactive">mock request and response</a>, or it can test any
web server over an HTTP connection.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Kotlin users: See <a href="languages.html#kotlin-webtestclient-issue">this section</a>
related to use of the <code>WebTestClient</code>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="webtestclient-setup"><a class="anchor" href="#webtestclient-setup"></a>3.7.1. Setup</h4>
<div class="paragraph">
<p>To create a <code>WebTestClient</code> you must choose one of several server setup options.
Effectively you&#8217;re either configuring the WebFlux application to bind to or using
a URL to connect to a running server.</p>
</div>
<div class="sect4">
<h5 id="webtestclient-controller-config"><a class="anchor" href="#webtestclient-controller-config"></a>Bind to Controller</h5>
<div class="paragraph">
<p>The following example shows how to create a server setup to test one <code>@Controller</code> at a time:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client = WebTestClient.bindToController(new TestController()).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client = WebTestClient.bindToController(TestController()).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example loads the <a href="web-reactive.html#webflux-config">WebFlux Java configuration</a>
and registers the given controller. The resulting WebFlux application is tested
without an HTTP server by using mock request and response objects. There are more methods
on the builder to customize the default WebFlux Java configuration.</p>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-fn-config"><a class="anchor" href="#webtestclient-fn-config"></a>Bind to Router Function</h5>
<div class="paragraph">
<p>The following example shows how to set up a server from a
<a href="web-reactive.html#webflux-fn">RouterFunction</a>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RouterFunction&lt;?&gt; route = ...
client = WebTestClient.bindToRouterFunction(route).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val route: RouterFunction&lt;*&gt; = ...
val client = WebTestClient.bindToRouterFunction(route).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Internally, the configuration is passed to <code>RouterFunctions.toWebHandler</code>.
The resulting WebFlux application is tested without an HTTP server by using mock
request and response objects.</p>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-context-config"><a class="anchor" href="#webtestclient-context-config"></a>Bind to <code>ApplicationContext</code></h5>
<div class="paragraph">
<p>The following example shows how to set up a server from the Spring configuration of your
application or some subset of it:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringJUnitConfig(WebConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTests {

    WebTestClient client;

    @BeforeEach
    void setUp(ApplicationContext context) {  <i class="conum" data-value="2"></i><b>(2)</b>
        client = WebTestClient.bindToApplicationContext(context).build(); <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify the configuration to load</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Inject the configuration</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Create the <code>WebTestClient</code></td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@SpringJUnitConfig(WebConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTests {

    lateinit var client: WebTestClient

    @BeforeEach
    fun setUp(context: ApplicationContext) { <i class="conum" data-value="2"></i><b>(2)</b>
        client = WebTestClient.bindToApplicationContext(context).build() <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify the configuration to load</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Inject the configuration</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Create the <code>WebTestClient</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Internally, the configuration is passed to <code>WebHttpHandlerBuilder</code> to set up the request
processing chain. See <a href="web-reactive.html#webflux-web-handler-api">WebHandler API</a> for
more details. The resulting WebFlux application is tested without an HTTP server by
using mock request and response objects.</p>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-server-config"><a class="anchor" href="#webtestclient-server-config"></a>Bind to Server</h5>
<div class="paragraph">
<p>The following server setup option lets you connect to a running server:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client = WebTestClient.bindToServer().baseUrl("http://localhost:8080").build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client = WebTestClient.bindToServer().baseUrl("http://localhost:8080").build()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-client-config"><a class="anchor" href="#webtestclient-client-config"></a>Client Builder</h5>
<div class="paragraph">
<p>In addition to the server setup options described earlier, you can also configure client
options, including base URL, default headers, client filters, and others. These options
are readily available following <code>bindToServer</code>. For all others, you need to use
<code>configureClient()</code> to transition from server to client configuration, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client = WebTestClient.bindToController(new TestController())
        .configureClient()
        .baseUrl("/test")
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client = WebTestClient.bindToController(TestController())
        .configureClient()
        .baseUrl("/test")
        .build()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webtestclient-tests"><a class="anchor" href="#webtestclient-tests"></a>3.7.2. Writing Tests</h4>
<div class="paragraph">
<p><code>WebTestClient</code> provides an API identical to <a href="web-reactive.html#webflux-client">WebClient</a>
up to the point of performing a request by using <code>exchange()</code>. What follows after
<code>exchange()</code> is a chained API workflow to verify responses.</p>
</div>
<div class="paragraph">
<p>Typically, you start by asserting the response status and headers, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client.get().uri("/persons/1")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.APPLICATION_JSON)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client.get().uri("/persons/1")
        .accept(MediaType.APPLICATION_JSON)
        .exchange()
        .expectStatus().isOk()
        .expectHeader().contentType(MediaType.APPLICATION_JSON)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you specify how to decode and consume the response body:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>expectBody(Class&lt;T&gt;)</code>: Decode to single object.</p>
</li>
<li>
<p><code>expectBodyList(Class&lt;T&gt;)</code>: Decode and collect objects to <code>List&lt;T&gt;</code>.</p>
</li>
<li>
<p><code>expectBody()</code>: Decode to <code>byte[]</code> for <a href="#webtestclient-json">JSON Content</a> or an empty body.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Then you can use built-in assertions for the body. The following example shows one way to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client.get().uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectBodyList(Person.class).hasSize(3).contains(person);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.test.web.reactive.server.expectBodyList

client.get().uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectBodyList&lt;Person&gt;().hasSize(3).contains(person)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also go beyond the built-in assertions and create your own, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.test.web.reactive.server.expectBody

client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody(Person.class)
        .consumeWith(result -&gt; {
            // custom assertions (e.g. AssertJ)...
        });</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody&lt;Person&gt;()
        .consumeWith {
            // custom assertions (e.g. AssertJ)...
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also exit the workflow and get a result, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">EntityExchangeResult&lt;Person&gt; result = client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody(Person.class)
        .returnResult();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.test.web.reactive.server.expectBody

val result = client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk
        .expectBody&lt;Person&gt;()
        .returnResult()</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When you need to decode to a target type with generics, look for the overloaded methods
that accept
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/core/ParameterizedTypeReference.html"><code>ParameterizedTypeReference</code></a>
instead of <code>Class&lt;T&gt;</code>.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="webtestclient-no-content"><a class="anchor" href="#webtestclient-no-content"></a>No Content</h5>
<div class="paragraph">
<p>If the response has no content (or you do not care if it does) use <code>Void.class</code>, which ensures
that resources are released. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client.get().uri("/persons/123")
        .exchange()
        .expectStatus().isNotFound()
        .expectBody(Void.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client.get().uri("/persons/123")
        .exchange()
        .expectStatus().isNotFound
        .expectBody&lt;Unit&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, if you want to assert there is no response content, you can use code similar to the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client.post().uri("/persons")
        .body(personMono, Person.class)
        .exchange()
        .expectStatus().isCreated()
        .expectBody().isEmpty();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client.post().uri("/persons")
        .bodyValue(person)
        .exchange()
        .expectStatus().isCreated()
        .expectBody().isEmpty()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-json"><a class="anchor" href="#webtestclient-json"></a>JSON Content</h5>
<div class="paragraph">
<p>When you use <code>expectBody()</code>, the response is consumed as a <code>byte[]</code>. This is useful for
raw content assertions. For example, you can use
<a href="https://jsonassert.skyscreamer.org">JSONAssert</a> to verify JSON content, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .json("{\"name\":\"Jane\"}")</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .json("{\"name\":\"Jane\"}")</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use <a href="https://github.com/jayway/JsonPath">JSONPath</a> expressions, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">client.get().uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .jsonPath("$[0].name").isEqualTo("Jane")
        .jsonPath("$[1].name").isEqualTo("Jason");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">client.get().uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .jsonPath("$[0].name").isEqualTo("Jane")
        .jsonPath("$[1].name").isEqualTo("Jason")</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-stream"><a class="anchor" href="#webtestclient-stream"></a>Streaming Responses</h5>
<div class="paragraph">
<p>To test infinite streams (for example, <code>"text/event-stream"</code> or <code>"application/stream+json"</code>),
you need to exit the chained API (by using <code>returnResult</code>), immediately after the response status
and header assertions, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">FluxExchangeResult&lt;MyEvent&gt; result = client.get().uri("/events")
        .accept(TEXT_EVENT_STREAM)
        .exchange()
        .expectStatus().isOk()
        .returnResult(MyEvent.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.test.web.reactive.server.returnResult

val result = client.get().uri("/events")
        .accept(TEXT_EVENT_STREAM)
        .exchange()
        .expectStatus().isOk()
        .returnResult&lt;MyEvent&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you can consume the <code>Flux&lt;T&gt;</code>, assert decoded objects as they come, and then
cancel at some point when test objectives are met. We recommend using the <code>StepVerifier</code>
from the <code>reactor-test</code> module to do that, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Event&gt; eventFlux = result.getResponseBody();

StepVerifier.create(eventFlux)
        .expectNext(person)
        .expectNextCount(4)
        .consumeNextWith(p -&gt; ...)
        .thenCancel()
        .verify();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val eventFlux = result.getResponseBody()

StepVerifier.create(eventFlux)
        .expectNext(person)
        .expectNextCount(4)
        .consumeNextWith { p -&gt; ... }
        .thenCancel()
        .verify()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-request-body"><a class="anchor" href="#webtestclient-request-body"></a>Request Body</h5>
<div class="paragraph">
<p>When it comes to building requests, the <code>WebTestClient</code> offers an API  identical to
the <code>WebClient</code>, and the implementation is mostly a simple pass-through. See the
<a href="web-reactive.html#webflux-client-body">WebClient documentation</a> for examples on
how to prepare a request with a body, including submitting form data, multipart requests,
and more.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-resources"><a class="anchor" href="#testing-resources"></a>4. Further Resources</h2>
<div class="sectionbody">
<div class="paragraph">
<p>See the following resources for more information about testing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.junit.org/">JUnit</a>: &#8220;A programmer-friendly testing framework for Java&#8221;.
Used by the Spring Framework in its test suite and supported in the
<a href="#testcontext-framework">Spring TestContext Framework</a>.</p>
</li>
<li>
<p><a href="https://testng.org/">TestNG</a>: A testing framework inspired by JUnit with added support
for test groups, data-driven testing, distributed testing, and other features. Supported
in the <a href="#testcontext-framework">Spring TestContext Framework</a></p>
</li>
<li>
<p><a href="https://joel-costigliola.github.io/assertj/">AssertJ</a>: &#8220;Fluent assertions for Java&#8221;,
including support for Java 8 lambdas, streams, and other features.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Mock_Object">Mock Objects</a>: Article in Wikipedia.</p>
</li>
<li>
<p><a href="http://www.mockobjects.com/">MockObjects.com</a>: Web site dedicated to mock objects, a
technique for improving the design of code within test-driven development.</p>
</li>
<li>
<p><a href="https://mockito.github.io">Mockito</a>: Java mock library based on the
<a href="http://xunitpatterns.com/Test%20Spy.html">Test Spy</a> pattern. Used by the Spring Framework
in its test suite.</p>
</li>
<li>
<p><a href="https://easymock.org/">EasyMock</a>: Java library &#8220;that provides Mock Objects for
interfaces (and objects through the class extension) by generating them on the fly using
Java&#8217;s proxy mechanism.&#8221;</p>
</li>
<li>
<p><a href="https://jmock.org/">JMock</a>: Library that supports test-driven development of Java code
with mock objects.</p>
</li>
<li>
<p><a href="https://www.dbunit.org/">DbUnit</a>: JUnit extension (also usable with Ant and Maven) that
is targeted at database-driven projects and, among other things, puts your database into
a known state between test runs.</p>
</li>
<li>
<p><a href="https://www.testcontainers.org/">Testcontainers</a>: Java library that supports JUnit
tests, providing lightweight, throwaway instances of common databases, Selenium web
browsers, or anything else that can run in a Docker container.</p>
</li>
<li>
<p><a href="https://sourceforge.net/projects/grinder/">The Grinder</a>: Java load testing framework.</p>
</li>
<li>
<p><a href="https://github.com/Ninja-Squad/springmockk">SpringMockK</a>: Support for Spring Boot
integration tests written in Kotlin using <a href="https://mockk.io/">MockK</a> instead of Mockito.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5.2.5.RELEASE<br>
Last updated 2020-03-24 11:23:46 UTC
</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>